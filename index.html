<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> anzhen.tech</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
      <meta name="baidu-site-verification" content="code-BgeZtJHZzY" />
      <meta name="google-site-verification" content="wNOxVwDPcgD6IwrCt_pD_Xtq-E86p8USRXPN73jLu0A" />
    <link rel="alternate" href="/atom.xml" title="anzhen.tech" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/anzhen-tech"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">anzhen.tech</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="anzhen.tech"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['越努力，越美好', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.aliyun.com/minisite/goods?userCode=e6rdw2zn&amp;share_source=copy_link">
                <img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/WX20211107-102324@2x.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10" width="300" alt="阿里云服务器">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java并发与多线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
    >Java并发与多线程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2021-11-07T02:56:22.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="并发与多线程"><a href="#并发与多线程" class="headerlink" title="并发与多线程"></a>并发与多线程</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol>
<li>volatile 有什么用？<ul>
<li>volatile 保证内存可见性和禁止指令重排。volatile 可以提供部分原子性。</li>
<li>volatile 用于多线程环境下的单次操作(单次读或者单次写)。</li>
</ul>
</li>
<li>volatile 变量和 atomic 变量有什么不同？<ul>
<li>volatile 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</li>
<li>AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 #getAndIncrement() 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
</li>
<li>Java 中能创建 volatile 数组吗?<ul>
<li>能创建但指向引用,不保证内部元素;</li>
</ul>
</li>
<li>volatile 能使得一个非原子操作变成原子操作吗？<ul>
<li>对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种读写复合操作不具有原子性。</li>
</ul>
</li>
<li>volatile 修饰符的有过什么实践？<ul>
<li>用 volatile 修饰 long 和 double 变量,使其读写支持原子性;</li>
<li>状态标志 Boolean 值;</li>
<li>独立观察,单独监测某个多个线程共享的变量</li>
<li>轻量级锁</li>
</ul>
</li>
<li>volatile 类型变量提供什么保证？<ul>
<li>volatile 变量提供顺序性和可见性保证</li>
<li>避免指令重排</li>
<li>可见性保证</li>
</ul>
</li>
<li>volatile 和 synchronized 的区别？<ul>
<li>volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。</li>
<li>volatile 标记的变量不会被编译器优化。synchronized标记的变量可以被编译器优化。</li>
</ul>
</li>
<li>什么场景下可以使用 volatile 替换 synchronized ？<ul>
<li>只需要保证共享资源的可见性的时候可以使用 volatile 替代，synchronized 保证可操作的原子性一致性和可见性。</li>
<li>volatile 适用于新值不依赖于旧值的情形。</li>
<li>1 写 N 读。</li>
<li>不与其他变量构成不变性条件时候使用 volatile 。<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2></li>
</ul>
</li>
<li>synchronized 的原理是什么?<ul>
<li>synchronized是 Java 内置的关键字，它提供了一种独占的加锁方式。</li>
<li>synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</li>
<li>synchronized 也有一定的局限性。<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li>
</ul>
</li>
</ul>
</li>
<li>同步方法和同步块，哪个是更好的选择？<ul>
<li>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</li>
<li>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</li>
</ul>
</li>
<li>当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？<ul>
<li>如果其他方法没有 synchronized 的话，其他线程是可以进入的。</li>
<li>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。、</li>
</ul>
</li>
<li>在监视器(Monitor)内部，是如何做线程同步的？<ul>
<li>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</li>
</ul>
</li>
<li>Java 如何实现“自旋”（spin） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!sign .compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// &lt;1.1&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span> </span>&#123; <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;1&gt; 处，#lock() 方法，如果获得不到锁，就会“死循环”，直到或得到锁为止。考虑到“死循环”会持续占用 CPU ，可能导致其它线程无法获得到 CPU 执行，可以在 &lt;1.1&gt; 处增加 Thread.yiead() 代码段，出让下 CPU 。</li>
<li>&lt;2&gt; 处，#unlock() 方法，释放锁。</li>
</ul>
</li>
</ol>
<p>#Java Lock 接口<br>    - <img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15852735326621.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
<ol>
<li>什么是 Java Lock 接口？<ul>
<li>java.util.concurrent.locks.Lock 接口，比 synchronized 提供更具拓展性的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：<ul>
<li>可以使锁更公平。</li>
<li>可以使线程在等待锁的时候响应中断。</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁。</li>
</ul>
</li>
</ul>
</li>
<li>什么是可重入锁（ReentrantLock）？<ul>
<li>举例来说明锁的可重入性。代码如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnReentrant</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>outer() 方法中调用了 #inner() 方法，#outer() 方法先锁住了 lock ，这样 #inner() 就不能再获取 lock 。</li>
<li>其实调用 #outer() 方法的线程已经获取了 lock 锁，但是不能在 #inner() 方法中重复利用已经获取的锁资源，这种锁即称之为不可重入。</li>
<li>可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</li>
<li>synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</li>
<li>ReenTrantLock 的实现是一种自旋锁，通过循环调用 CAS 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</li>
</ul>
</li>
<li>synchronized 和 ReentrantLock 异同？<ul>
<li>相同点<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
</li>
<li>不同点<ul>
<li>同步实现机制不同<ul>
<li>synchronized 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li>synchronized 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 volatile state 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li>synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 finally 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li>synchronized 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li>synchronized 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ReadWriteLock 是什么？<ul>
<li>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</li>
<li>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</li>
<li>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：<ul>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ul>
</li>
</ul>
</li>
<li>Condition 是什么？<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15852741845639.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10" alt="-w762"><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2></li>
</ul>
</li>
<li>两个线程之间是如何通信的呢？<ul>
<li>线程之间的通信方式，目前有共享内存和消息传递两种。<ul>
<li>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15852745337896.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 #wait() 和 #notify() ，或者 BlockingQueue 。<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15852745812427.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为什么代码会重排序？<ul>
<li>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<ul>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<blockquote>
<p>重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="Java-并发容器"><a href="#Java-并发容器" class="headerlink" title="Java 并发容器"></a>Java 并发容器</h2><ol>
<li>Java 中 ConcurrentHashMap 的并发度是什么？<ul>
<li>锁单个Node节点</li>
</ul>
</li>
<li>ConcurrentHashMap 为何读不用加锁？<ul>
<li>Node 的 val 和 next 均为 volatile 型。</li>
<li>tabAt(..,) 和 casTabAt(…) 对应的 Unsafe 操作实现了 volatile 语义。</li>
</ul>
</li>
<li>CopyOnWriteArrayList 可以用于什么应用场景？<ul>
<li>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException 异常。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 ygc 或者 fgc 。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
</ul>
</li>
<li>CopyOnWriteArrayList 透露的思想：</li>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突<h2 id="Java-阻塞队列"><a href="#Java-阻塞队列" class="headerlink" title="Java 阻塞队列"></a>Java 阻塞队列</h2></li>
</ul>
</li>
<li>什么是阻塞队列？有什么适用场景？<ul>
<li>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
</li>
<li>阻塞队列常用于生产者和消费者的场景：<ul>
<li>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程</li>
<li>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</li>
</ul>
</li>
<li>BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：<ul>
<li>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。</li>
<li>当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。</li>
<li>正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。</li>
<li>阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：<ul>
<li>读取数据的线程不断将数据放入队列。</li>
<li>然后，解析线程不断从队列取数据解析。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java 提供了哪些阻塞队列的实现？<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
</li>
<li>简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？<ul>
<li>阻塞队列，典型例子是 LinkedBlockingQueue 。使用阻塞队列的好处：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。</li>
<li>非阻塞队列，典型例子是 ConcurrentLinkedQueue 。当许多线程共享访问一个公共集合时，ConcurrentLinkedQueue 是一个恰当的选择。</li>
<li>具体的选择，如下：<ul>
<li>LinkedBlockingQueue 多用于任务队列。<ul>
<li>单生产者，单消费者</li>
<li>多生产者，单消费者</li>
</ul>
</li>
<li>ConcurrentLinkedQueue 多用于消息队列。<ul>
<li>单生产者，多消费者</li>
<li>多生产者，多消费者</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Java-原子操作类"><a href="#Java-原子操作类" class="headerlink" title="Java 原子操作类"></a>Java 原子操作类</h2><ol>
<li>什么是原子操作？<ul>
<li>原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。</li>
<li>处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。</li>
<li>在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。CAS操作 —— Compare &amp; Set ，或是 Compare &amp; Swap ，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</li>
</ul>
</li>
<li>CAS 操作有什么缺点？<ul>
<li>ABA 问题<ul>
<li>比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。</li>
</ul>
</li>
<li>循环时间长开销大<ul>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。<h2 id="Java-并发工具类"><a href="#Java-并发工具类" class="headerlink" title="Java 并发工具类"></a>Java 并发工具类</h2></li>
</ul>
</li>
</ul>
</li>
<li>Semaphore 是什么？<ul>
<li>Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。<ul>
<li>如有必要，在许可可用前会阻塞每一个 #acquire() 方法，然后再获取该许可。</li>
<li>每个 #release() 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。</li>
</ul>
</li>
</ul>
</li>
<li>说说 CountDownLatch 原理<ul>
<li>CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。</li>
<li>CountDownLatch 默认的构造方法是 CountDownLatch(int count) ，其参数表需要减少的计数，主线程调用 #await() 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，然后其它线程调用 CountDownLatch 的 #countDown() 方法，减小计数(不会阻塞)。等待计数被减少到零，主线程结束阻塞等待，继续往下执行。</li>
</ul>
</li>
<li>说说 CyclicBarrier 原理<ul>
<li>CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li>
<li>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties) ，其参数表示屏障拦截的线程数量，每个线程调用 #await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞，直到 parties 个线程到达，结束阻塞。</li>
</ul>
</li>
<li>CyclicBarrier 和 CountdownLatch 有什么区别？<ul>
<li>CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</li>
<li>CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。</li>
<li>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)</li>
</ul>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为 0 时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为 0 时，无法重置</td>
<td>计数达到指定值时，计数置为 0 重新开始</td>
</tr>
<tr>
<td>调用 #countDown() 方法计数减一，调用 #await() 方法只进行阻塞，对计数没任何影响</td>
<td>调用 #await() 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h2><ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15852766289037.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
<ol>
<li>什么是 Executor 框架？<ul>
<li>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</li>
<li>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</li>
</ul>
</li>
<li>为什么使用 Executor 框架？<ul>
<li>每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时、耗资源的。</li>
<li>调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li>
<li>接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li>
</ul>
</li>
<li>在 Java 中 Executor 和 Executors 的区别？<ul>
<li>Executors 是 Executor 的工具类，不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 是接口对象，能执行我们的线程任务。<ul>
<li>ExecutorService 接口，继承了 Executor 接口，并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
<li>使用 ThreadPoolExecutor ，可以创建自定义线程池。</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 #get() 方法，获取计算的结果。</li>
</ul>
</li>
</ul>
</li>
<li>创建线程池的几种方式？<ul>
<li>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。<ul>
<li>普通任务线程池<ul>
<li>1、#newFixedThreadPool(int nThreads) 方法，创建一个固定长度的线程池。每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
<li>2、#newCachedThreadPool() 方法，创建一个可缓存的线程池。如果线程池的规模超过了处理需求，将自动回收空闲线程。当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
<li>3、#newSingleThreadExecutor() 方法，创建一个单线程的线程池。它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
<li>定时任务线程池<ul>
<li>4、#newScheduledThreadPool(int corePoolSize) 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li>5、#newSingleThreadExecutor() 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何使用 ThreadPoolExecutor 创建线程池？ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                      TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize 参数，核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行任务。</li>
<li>maximumPoolSize 参数，最大线程数， 当线程数 &gt;= corePoolSize 的时候，会把任务放入 workQueue 队列中。</li>
<li>keepAliveTime 参数，保持存活时间，当线程数大于 corePoolSize 的空闲线程能保持的最大时间。</li>
<li>unit 参数，时间单位。</li>
<li>workQueue 参数，保存任务的阻塞队列。</li>
<li>handler 参数，超过阻塞队列的大小时，使用的拒绝策略。</li>
<li>threadFactory 参数，创建线程的工厂。</li>
</ul>
</li>
<li>ThreadPoolExecutor 有哪些拒绝策略？<ul>
<li>ThreadPoolExecutor 默认有四个拒绝策略：<ul>
<li>ThreadPoolExecutor.AbortPolicy() ，直接抛出异常 RejectedExecutionException 。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy() ，直接调用 run 方法并且阻塞执行。</li>
<li>ThreadPoolExecutor.DiscardPolicy() ，直接丢弃后来的任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy() ，丢弃在队列中队首的任务。</li>
<li>如果有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑</li>
</ul>
</li>
</ul>
</li>
<li>线程池的关闭方式有几种？<ul>
<li>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：<ul>
<li>shutdown() 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li>shutdownNow() 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
</li>
</ul>
</li>
<li>Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？<ul>
<li>如果是 CPU 密集型应用，则线程池大小设置为 N+1<ul>
<li>因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</li>
</ul>
</li>
<li>如果是 IO 密集型应用，则线程池大小设置为 2N+1<ul>
<li>IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。</li>
</ul>
</li>
<li>如果是混合型应用，那么分别创建线程池<ul>
<li>可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。</li>
<li>因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</li>
</ul>
</li>
</ul>
</li>
<li>线程池容量的动态调整？<ul>
<li>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：<ul>
<li>setCorePoolSize：设置核心池大小。</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
</li>
<li>当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。</li>
</ul>
</li>
<li>什么是 Callable、Future、FutureTask ？ <ul>
<li>Callable: 可以认为是带有回调的 Runnable 。</li>
<li>Future: 表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</li>
<li>FutureTask; 表示一个可以取消的异步运算。<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
</li>
</ul>
</li>
<li>线程池执行任务的过程？<ul>
<li>刚创建时，里面没有线程调用 execute() 方法，添加任务时：<ul>
<li>如果正在运行的线程数量小于核心参数 corePoolSize ，继续创建线程运行这个任务<ul>
<li>否则，如果正在运行的线程数量大于或等于 corePoolSize ，将任务加入到阻塞队列中。<ul>
<li>否则，如果队列已满，同时正在运行的线程数量小于核心参数 maximumPoolSize ，继续创建线程运行这个任务。<ul>
<li>否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize ，根据设置的拒绝策略处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>完成一个任务，继续取下一个任务处理。<ul>
<li>没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。</li>
<li>否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 corePoolSize 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线程池中 submit 和 execute 方法有什么区别？<ul>
<li>两个方法都可以向线程池提交任务。<ul>
<li>execute(…) 方法，返回类型是 void ，它定义在 Executor 接口中。</li>
<li>submit(…) 方法，可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
</li>
</ul>
</li>
<li>如果你提交任务时，线程池队列已满，这时会发生什么？<ul>
<li>重点在于线程池的队列是有界还是无界的。</li>
</ul>
</li>
<li>Fork/Join 框架是什么？<ul>
<li>Fork/Join 框架是一个实现了 ExecutorService接口 的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。</li>
<li>Fork 就是把一个大任务切分为若干子任务并行的执行</li>
<li>Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li>比如计算 1+2+…＋10000 ，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</li>
</ul>
</li>
<li>如何让一段程序并发的执行，并最终汇总结果？<ul>
<li>1、CountDownLatch：允许一个或者多个线程等待前面的一个或多个线程完成，构造一个 CountDownLatch 时指定需要 countDown 的点的数量，每完成一点就 countDown 一下。当所有点都完成，CountDownLatch 的 #await() 就解除阻塞。</li>
<li>2、CyclicBarrier：可循环使用的 Barrier ，它的作用是让一组线程到达一个 Barrier 后阻塞，直到所有线程都到达 Barrier 后才能继续执行。</li>
<li>3、Fork/Join 框架，fork 把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-RocketMQ"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/RocketMQ/"
    >RocketMQ</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/RocketMQ/" class="article-date">
  <time datetime="2021-11-07T02:54:34.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><ol>
<li>RocketMQ 由哪些角色组成？<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850381816926.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li>
<li>消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li>
<li>消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li>
<li>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li>
</ul>
</li>
<li>请描述下 RocketMQ 的整体流程？<pre><code> - ![](https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850382480500.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10)
</code></pre>
<ul>
<li>启动 Namesrv，Namesrv起 来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</li>
<li>Broker 启动，<strong>跟所有的 Namesrv 保持长连接</strong>，定时发送心跳包。心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。注册成功后，Namesrv 集群中就有 Topic 跟 Broker 的映射关系。</li>
<li>收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在 哪些 Broker上。也可以在发送消息时自动创建Topic。</li>
<li>Producer 发送消息。启动时，先跟 Namesrv 集群中的其中一台建立长连接，并从Namesrv 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息</li>
<li>Consumer 消费消息。Consumer 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</li>
</ul>
</li>
<li>请说说你对 Namesrv 的了解？<ul>
<li>Namesrv 用于存储 Topic、Broker 关系信息，功能简单，稳定性高。<ul>
<li>多个 Namesrv 之间相互没有通信，单台 Namesrv 宕机不影响其它 Namesrv 与集群。多个 Namesrv 之间的信息共享，通过 Broker 主动向多个 Namesrv 都发起心跳。正如上文所说，Broker 需要跟所有 Namesrv 连接。</li>
<li>即使整个 Namesrv 集群宕机，已经正常工作的 Producer、Consumer、Broker 仍然能正常工作，但新起的 Producer、Consumer、Broker 就无法工作。(这点和 Dubbo 有些不同，不会缓存 Topic 等元信息到本地文件。)</li>
</ul>
</li>
<li> Namesrv 压力不会太大，平时主要开销是在维持心跳和提供 Topic-Broker 的关系数据。但有一点需要注意，Broker 向 Namesr 发心跳时，会带上当前自己所负责的所有 Topic 信息，如果 Topic 个数太多（万级别），会导致一次心跳中，就 Topic 的数据就几十 M，网络情况差的话，网络传输失败，心跳失败，导致 Namesrv 误认为 Broker 心跳失败。</li>
</ul>
</li>
<li>如何配置 Namesrv 地址到生产者和消费者？<ul>
<li><strong>编程方式</strong>，就像 producer.setNamesrvAddr(“ip:port”) 。</li>
<li>Java 启动参数设置，使用 rocketmq.namesrv.addr 。</li>
<li>环境变量，使用 NAMESRV_ADDR 。</li>
<li>HTTP 端点，例如说：<a target="_blank" rel="noopener" href="http://namesrv.rocketmq.xxx.com/">http://namesrv.rocketmq.xxx.com</a> 地址，通过 DNS 解析获得 Namesrv 真正的地址。</li>
</ul>
</li>
<li>请说说你对 Broker 的了解？<ul>
<li>高并发读写服务。Broker的高并发读写主要是依靠以下两点:<ul>
<li>消息顺序写，所有 Topic 数据同时只会写一个文件，一个文件满1G ，再写新文件，真正的顺序写盘，使得发消息 TPS 大幅提高。</li>
<li>消息随机读，RocketMQ 尽可能让读命中系统 Pagecache ，因为操作系统访问 Pagecache 时，即使只访问 1K 的消息，系统也会提前预读出更多的数据，在下次读时就可能命中 Pagecache ，减少 IO 操作。</li>
</ul>
</li>
<li>负载均衡与动态伸缩。<ul>
<li>负载均衡：Broker 上存 Topic 信息，Topic 由多个队列组成，队列会平均分散在多个 Broker 上，而 Producer 的发送机制保证消息尽量平均分布到所有队列中，最终效果就是所有消息都平均落在每个 Broker 上。</li>
<li>动态伸缩能力（非顺序消息）：Broker 的伸缩性体现在两个维度：Topic、Broker。<ul>
<li>Topic 维度：假如一个 Topic 的消息量特别大，但集群水位压力还是很低，就可以扩大该 Topic 的队列数， Topic 的队列数跟发送、消费速度成正比。<ul>
<li>Topic 的队列数一旦扩大，就无法很方便的缩小。因为，生产者和消费者都是基于相同的队列数来处理。如果真的想要缩小，只能新建一个 Topic ，然后使用它。</li>
</ul>
</li>
<li>Broker 维度：如果集群水位很高了，需要扩容，直接加机器部署 Broker 就可以。Broker 启动后向 Namesrv 注册，Producer、Consumer 通过 Namesrv 发现新Broker，立即跟该 Broker 直连，收发消息。<ul>
<li>新增的 Broker 想要下线，想要下线也比较麻烦，暂时没特别好的方案。大体的前提是，消费者消费完该 Broker 的消息，生产者不往这个 Broker 发送消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高可用 &amp; 高可靠。<ul>
<li>高可用：集群部署时一般都为主备，备机实时从主机同步消息，如果其中一个主机宕机，备机提供消费服务，但不提供写服务。</li>
<li>高可靠：所有发往 Broker 的消息，有同步刷盘和异步刷盘机制。<ul>
<li>同步刷盘时，消息写入物理文件才会返回成功。</li>
<li>异步刷盘时，只有机器宕机，才会产生消息丢失，Broker 挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电。如果 Broker 挂掉，未同步到硬盘的消息，还在 Pagecache 中呆着。</li>
</ul>
</li>
</ul>
</li>
<li>Broker 与 Namesrv 的心跳机制。<ul>
<li>单个 Broker 跟所有 Namesrv 保持心跳请求，心跳间隔为30秒，心跳请求中包括当前 Broker 所有的 Topic 信息。</li>
<li>Namesrv 会反查 Broker 的心跳信息，如果某个 Broker 在 2 分钟之内都没有心跳，则认为该 Broker 下线，调整 Topic 跟 Broker 的对应关系。但此时 Namesrv 不会主动通知Producer、Consumer 有 Broker 宕机。也就说，只能等 Producer、Consumer 下次定时拉取 Topic 信息的时候，才会发现有 Broker 宕机。</li>
</ul>
</li>
</ul>
</li>
<li>Broker 如何实现消息的存储？<ul>
<li>?????????????????????????</li>
</ul>
</li>
<li>请说说你对 Producer 的了解？<ul>
<li>获得 Topic-Broker 的映射关系。<ul>
<li>Producer 启动时，也需要指定 Namesrv 的地址，从 Namesrv 集群中选一台建立长连接。如果该 Namesrv 宕机，会自动连其他 Namesrv ，直到有可用的 Namesrv 为止。</li>
<li>生产者每 30 秒从 Namesrv 获取 Topic 跟 Broker 的映射关系，更新到本地内存中。然后再跟 Topic 涉及的所有 Broker 建立长连接，每隔 30 秒发一次心跳。</li>
<li>在 Broker 端也会每 10 秒扫描一次当前注册的 Producer ，如果发现某个 Producer 超过 2 分钟都没有发心跳，则断开连接。</li>
</ul>
</li>
<li>生产者端的负载均衡。<ul>
<li>生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上。</li>
<li>假如某个 Broker 宕机，意味生产者最长需要 30 秒才能感知到。在这期间会向宕机的 Broker 发送消息。当一条消息发送到某个 Broker 失败后，会自动再重发 2 次，假如还是发送失败，则抛出发送失败异常。客户端里会自动轮询另外一个 Broker 重新发送，这个对于用户是透明的。</li>
</ul>
</li>
</ul>
</li>
<li>Producer 发送消息有几种方式？<ul>
<li>Producer 发送消息，有三种方式：<ul>
<li>同步方式</li>
<li>异步方式</li>
<li>Oneway 方式</li>
</ul>
</li>
</ul>
</li>
<li>请说说你对 Consumer 的了解？<ul>
<li>获得 Topic-Broker 的映射关系。<ul>
<li>Consumer 启动时需要指定 Namesrv 地址，与其中一个 Namesrv 建立长连接。消费者每隔 30 秒从 Namesrv 获取所有Topic 的最新队列情况，这意味着某个 Broker 如果宕机，客户端最多要 30 秒才能感知。连接建立后，从 Namesrv 中获取当前消费 Topic 所涉及的 Broker，直连 Broker 。</li>
<li>Consumer 跟 Broker 是长连接，会每隔 30 秒发心跳信息到Broker 。Broker 端每 10 秒检查一次当前存活的 Consumer ，若发现某个 Consumer 2 分钟内没有心跳，就断开与该 Consumer 的连接，并且向该消费组的其他实例发送通知，触发该消费者集群的负载均衡。</li>
</ul>
</li>
<li>消费者端的负载均衡。根据消费者的消费模式不同，负载均衡方式也不同。<ul>
<li>集群消费：一个 Topic 可以由同一个消费这分组( Consumer Group )下所有消费者分担消费。<ul>
<li>具体例子：假如 TopicA 有 6 个队列，，每个消费者分组起了 2 个消费者实例，那么每个消费者负责消费 3 个队列。如果再增加一个消费者分组相同消费者实例，即当前共有 3 个消费者同时消费 6 个队列，那每个消费者负责 2 个队列的消费。</li>
</ul>
</li>
<li>广播消费：每个消费者消费 Topic 下的所有队列。</li>
</ul>
</li>
</ul>
</li>
<li>消费者消费模式有几种？<ul>
<li>集群消费：一个 Consumer Group 中的各个 Consumer 实例分摊去消费消息，即一条消息只会投递到一个 Consumer Group 下面的一个实例。<ul>
<li>实际上，每个 Consumer 是平均分摊 Message Queue 的去做拉取消费。例如某个 Topic 有 3 个队列，其中一个 Consumer Group 有 3 个实例（可能是 3 个进程，或者 3 台机器），那么每个实例只消费其中的 1 个队列。</li>
<li>而由 Producer 发送消息的时候是轮询所有的队列，所以消息会平均散落在不同的队列上，可以认为队列上的消息是平均的。那么实例也就平均地消费消息了。</li>
<li>这种模式下，消费进度的存储会持久化到 Broker 。</li>
<li>当新建一个 Consumer Group 时，默认情况下，该分组的消费者会从 min offset 开始重新消费消息。</li>
</ul>
</li>
<li>广播消费：消息将对一 个Consumer Group 下的各个 Consumer 实例都投递一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。<ul>
<li>实际上，是一个消费组下的每个消费者实例都获取到了 Topic 下面的每个 Message Queue 去拉取消费。所以消息会投递到每个消费者实例。</li>
<li>这种模式下，消费进度会存储持久化到实例本地。</li>
</ul>
</li>
</ul>
</li>
<li>消费者获取消息有几种模式？<ul>
<li>PushConsumer推送模式（虽然 RocketMQ 使用的是长轮询）的消费者。消息的能及时被消费。使用非常简单，内部已处理如线程池消费、流控、负载均衡、异常处理等等的各种场景。</li>
<li>PullConsumer拉取模式的消费者。应用主动控制拉取的时机，怎么拉取，怎么消费等。主动权更高。但要自己处理各种场景。</li>
<li>决绝绝大多数场景下，我们只会使用 PushConsumer 推送模式。</li>
</ul>
</li>
<li>如何对消息进行重放？<ul>
<li>消费位点就是一个数字，把 Consumer Offset 改一下，就可以达到重放的目的了。</li>
</ul>
</li>
<li>什么是顺序消息？如何实现？<ul>
<li>消费消息的顺序要同发送消息的顺序一致。由于 Consumer 消费消息的时候是针对 Message Queue 顺序拉取并开始消费，且一条 Message Queue 只会给一个消费者（集群模式下），所以能够保证同一个消费者实例对于 Queue 上消息的消费是顺序地开始消费（不一定顺序消费完成，因为消费可能并行）。</li>
<li>RocketMQ 提供了两种顺序级别：<ul>
<li>顺序消息包括两块：Producer 的顺序发送，和 Consumer 的顺序消费。</li>
<li>普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。</li>
<li>严格顺序消息 ：在【普通顺序消息】的基础上，Consumer 严格顺序消费。</li>
</ul>
</li>
</ul>
</li>
<li>顺序消息扩容的过程中，如何在不停写的情况下保证消息顺序？<ul>
<li>成倍扩容，实现扩容前后，同样的 key，hash 到原队列，或者 hash 到新扩容的队列。</li>
<li>扩容前，记录旧队列中的最大位点。</li>
<li>对于每个 Consumer Group ，保证旧队列中的数据消费完，再消费新队列，也即：先对新队列进行禁读即可。</li>
</ul>
</li>
<li>什么是定时消息？如何实现？<ul>
<li>定时消息，是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。</li>
<li>可通过配置文件，自定义每个延迟级别对应的延迟时间。当然，这是全局的。</li>
<li>如果想要实现任一时刻的延迟消息，比较简单的方式是插入延迟消息到数据库中，然后通过定时任务轮询，到达指定时间，发送到 RocketMQ 中。</li>
<li>实现原理：<ul>
<li>定时消息发送到 Broker 后，会被存储 Topic 为 SCHEDULE_TOPIC_XXXX 中，并且所在 Queue 编号为延迟级别 - 1 。（需要 -1 的原因是，延迟级别是从 1 开始的。如果延迟级别为 0 ，意味着无需延迟。）</li>
<li>Broker 针对每个 SCHEDULE_TOPIC_XXXX 的队列，都创建一个定时任务，顺序扫描到达时间的延迟消息，重新存储到延迟消息原始的 Topic 的原始 Queue 中，这样它就可以被 Consumer 消费到。<ul>
<li>为什么是“顺序扫描到达时间的延迟消息”？因为先进 SCHEDULE_TOPIC_XXXX 的延迟消息，在其所在的队列，意味着先到达延迟时间。</li>
<li>会不会存在重复扫描的情况？每个 SCHEDULE_TOPIC_XXXX 的扫描进度，会每 10s 存储到 config/delayOffset.json 文件中，所以正常情况下，不会存在重复扫描。如果异常关闭，则可能导致重复扫描。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>什么是消息重试？如何实现？<ul>
<li>消息重试，Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。</li>
<li>Consumer 会将消费失败的消息发回 Broker，进入延迟消息队列。即，消费失败的消息，不会立即消费。也就是说，消息重试是构建在定时消息之上的功能。</li>
<li>消息重试的主要流程：<ul>
<li>Consumer 消费失败，将消息发送回 Broker 。</li>
<li>Broker 收到重试消息之后置换 Topic ，存储消息。</li>
<li>Consumer 会拉取该 Topic 对应的 retryTopic 的消息。</li>
<li>Consumer 拉取到 retryTopic 消息之后，置换到原始的 Topic ，把消息交给 Listener 消费。<ul>
<li>Consumer 消息失败后，会将消息的 Topic 修改为 %RETRY% + Topic 进行，添加 “RETRY_TOPIC” 属性为原始 Topic ，然后再返回给 Broker 中。</li>
<li>Broker 收到重试消息之后，会有两次修改消息的 Topic 。<ul>
<li>首先，会将消息的 Topic 修改为 %RETRY% + ConsumerGroup ，因为这个消息是当前消费这分组消费失败，只能被这个消费组所重新消费。注意，消费者会默认订阅 Topic 为 %RETRY% + ConsumerGroup 的消息。</li>
<li>然后，会将消息的 Topic 修改为 SCHEDULE_TOPIC_XXXX ，添加 “REAL_TOPIC” 属性为 %RETRY% + ConsumerGroup ，因为重试消息需要延迟消费。</li>
<li>Consumer 会拉取该 Topic 对应的 retryTopic 的消息，此处的 retryTopic 为 %RETRY% + ConsumerGroup 。<br>Consumer 拉取到 retryTopic 消息之后，置换到原始的 Topic ，因为有消息的 “RETRY_TOPIC” 属性是原始 Topic ，然后把消息交给 Listener 消费。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于RocketMQ的分布式事务解决方案<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850377370094.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>1、在扣款之前，先发送预备消息</li>
<li>2、发送预备消息成功后，执行本地扣款事务</li>
<li>3、扣款成功后，再发送确认消息</li>
<li>4、消息端（加钱业务）可以看到确认消息，消费此消息，进行加钱<blockquote>
<p>注意：上面的确认消息可以为commit消息，可以被订阅者消费；也可以是Rollback消息，即执行本地扣款事务失败后，提交rollback消息，即删除那个预备消息，订阅者无法消费</p>
</blockquote>
</li>
<li>异常1：如果发送预备消息失败，下面的流程不会走下去；这个是正常的</li>
<li>异常2：如果发送预备消息成功，但执行本地事务失败；这个也没有问题，因为此预备消息不会被消费端订阅到，消费端不会执行业务。</li>
<li>异常3：如果发送预备消息成功，执行本地事务成功，但发送确认消息失败；这个就有问题了，因为用户A扣款成功了，但加钱业务没有订阅到确认消息，无法加钱。这里出现了数据不一致。</li>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850378513462.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>RocketMq解决上面的问题，核心思路就是【状态回查】，也就是RocketMq会定时遍历commitlog中的预备消息。<blockquote>
<p>因为预备消息最终肯定会变为commit消息或Rollback消息，所以遍历预备消息去回查本地业务的执行状态，如果发现本地业务没有执行成功就rollBack，如果执行成功就发送commit消息。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-SpringMVC"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/SpringMVC/"
    >SpringMVC</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/SpringMVC/" class="article-date">
  <time datetime="2021-11-07T02:53:39.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring-MVC"></a>Spring-MVC</h1><ol>
<li>Spring MVC 框架有什么用？<ul>
<li>Spring Web MVC 框架提供”模型-视图-控制器”( Model-View-Controller )架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</li>
<li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li>
</ul>
</li>
<li>介绍下 Spring MVC 的核心组件？<ul>
<li>Spring MVC 一共有九大核心组件，分别是：<ul>
<li>MultipartResolver</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ul>
</li>
</ul>
</li>
<li>描述一下 DispatcherServlet 的工作流程？<br> <img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850164969118.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10" alt="-w803"><ul>
<li><ol>
<li>发送请求:用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器 DispatcherServlet 捕获。</li>
</ol>
</li>
<li><ol start="2">
<li>映射处理器:DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回。</li>
</ol>
</li>
<li><ol start="3">
<li>处理器适配:</li>
<li>DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 #preHandler(…) 方法）。</li>
<li>提取请求 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ol>
<li>HttpMessageConverter ：会将请求消息（如 JSON、XML 等数据）转换成一个对象。</li>
<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。</li>
</ol>
</li>
</ol>
</li>
<li><ol start="4">
<li>Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象。</li>
</ol>
</li>
<li><ol start="5">
<li>解析视图:根据返回的 ModelAndView ，选择一个适合的 ViewResolver</li>
</ol>
</li>
<li>6 7 渲染视图 + 响应请求</li>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850167871281.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li>@Controller 注解有什么用？<ul>
<li>@Controller 注解，它将一个类标记为 Spring Web MVC 控制器 Controller 。</li>
</ul>
</li>
<li>@RestController 和 @Controller 有什么区别？<ul>
<li>@RestController 注解，在 @Controller 基础上，增加了 @ResponseBody 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 “ACCEPT” 请求头来决定。</li>
</ul>
</li>
<li>@RequestMapping 注解有什么用？<ul>
<li>@RequestMapping 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<ul>
<li>类级别：映射请求的 URL。</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法。</li>
</ul>
</li>
</ul>
</li>
<li>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？<ul>
<li>@RequestMapping 可注解在类和方法上；@GetMapping 仅可注册在方法上。</li>
<li>@RequestMapping 可进行 GET、POST、PUT、DELETE 等请求方法</li>
<li>@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ul>
</li>
<li>返回 JSON 格式使用什么注解？<ul>
<li>可以使用 @ResponseBody 注解，或者使用包含 @ResponseBody 注解的 @RestController 注解。</li>
<li>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter 。</li>
</ul>
</li>
<li>介绍一下 WebApplicationContext ？<ul>
<li>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</li>
<li>它允许从相对于 Web 根目录的路径中加载配置文件，完成初始化 Spring MVC 组件的工作。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
</li>
<li>Spring MVC 的异常处理？<ul>
<li>Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，将处理器( handler )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。代码如下：</li>
<li>一般情况下，我们使用 @ExceptionHandler 注解来实现过异常的处理</li>
</ul>
</li>
<li>Spring MVC 有什么优点？<ul>
<li>使用真的真的真的非常方便，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。</li>
<li>提供拦截器机制，可以方便的对请求进行拦截处理。</li>
<li>提供异常机制，可以方便的对异常做统一处理。</li>
<li>可以任意使用各种视图技术，而不仅仅局限于 JSP ，例如 Freemarker、Thymeleaf 等等。</li>
<li>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，当然仅仅依赖 Servlet ，而不依赖 Filter、Listener )。</li>
</ul>
</li>
<li>Spring MVC 怎样设定重定向和转发 ？<ul>
<li>结果转发：在返回值的前面加 “forward:/“ 。</li>
<li>重定向：在返回值的前面加上 “redirect:/“ 。</li>
</ul>
</li>
<li>Spring MVC 的 Controller 是不是单例？<ul>
<li>绝绝绝大多数情况下，Controller 是单例。</li>
<li>那么，Controller 里一般不建议存在共享的变量。</li>
</ul>
</li>
<li>Spring MVC 和 Struts2 的异同？<ul>
<li>入口不同<ul>
<li>Spring MVC 的入门是一个 Servlet 控制器。</li>
<li>Struts2 入门是一个 Filter 过滤器。</li>
</ul>
</li>
<li>配置映射不同，<ul>
<li>Spring MVC 是基于方法开发，传递参数是通过方法形参，一般设置为单例。</li>
<li>Struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
</ul>
</li>
</ul>
</li>
<li>详细介绍下 Spring MVC 拦截器？<ul>
<li><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// HandlerInterceptor.java</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">        		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="params"><span class="function">        		<span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 并且，只有该处理器 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="params"><span class="function">        		<span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>preHandle(…) 方法，调用 Controller 方法之前执行。<ul>
<li>preHandle(…) 方法，按拦截器定义顺序调用。若任一拦截器返回 false ，则 Controller 方法不再调用。    </li>
</ul>
</li>
<li>postHandle(…) 方法，调用 Controller 方法之后执行。<ul>
<li>postHandle(…) 和 #afterCompletion(…) 方法，按拦截器定义逆序调用。</li>
<li>postHandler(…) 方法，在调用 Controller 方法之后执行。</li>
</ul>
</li>
<li>afterCompletion(…) 方法，处理完 Controller 方法返回结果之后执行,无论调用 Controller 方法是否成功，都会执行。<ul>
<li>afterCompletion(…) 方法，只有该拦截器在 #preHandle(…) 方法返回 true 时，才能够被调用，且一定会被调用。为什么“且一定会被调用”呢？即使 #afterCompletion(…) 方法，按拦截器定义逆序调用时，前面的拦截器发生异常，后面的拦截器还能够调用，即无视异常。</li>
</ul>
</li>
</ul>
</li>
<li>Spring MVC 的拦截器可以做哪些事情？<ul>
<li>记录访问日志。</li>
<li>记录异常日志。</li>
<li>需要登陆的请求操作，拦截未登陆的用户。</li>
<li>参数替换</li>
</ul>
</li>
<li>Spring MVC 的拦截器和 Filter 过滤器有什么差别？<ul>
<li>功能相同：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li>
<li>容器不同：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li>
<li>使用便利性不同：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li>
</ul>
</li>
</ol>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><ol>
<li>REST 代表着什么?<ul>
<li>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。</li>
</ul>
</li>
<li>资源是什么?<ul>
<li>资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，它允许客户端通过 HTTP 方法如：GET, POST,PUT, DELETE 等读，写，修改和创建资源。</li>
</ul>
</li>
<li>什么是安全的 REST 操作?<ul>
<li>REST 接口是通过 HTTP 方法完成操作。<ul>
<li>一些HTTP操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源换句话说，PUT,POST 和 DELETE 是不安全的，因为他们能修改服务端的资源。</li>
</ul>
</li>
<li>是否安全的界限，在于是否修改服务端的资源。</li>
</ul>
</li>
<li>什么是幂等操作? 为什么幂等操作如此重要?<ul>
<li>有一些HTTP方法，如：GET，不管你使用多少次它都能产生相同的结果，在没有任何一边影响的情况下，发送多个 GET 请求到相同的URI 将会产生相同的响应结果。因此，这就是所谓幂等操作。</li>
<li>换句话说，POST方法不是幂等操作 ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是，假如你用PUT更新资源，它将是幂等操作。</li>
</ul>
</li>
<li>REST 是可扩展的或说是协同的吗?<ul>
<li>是的，REST 是可扩展的和可协作的。它既不托管一种特定的技术选择，也不定在客户端或者服务端。你可以用 Java, C++, Python, 或 JavaScript 来创建 RESTful Web 服务，也可以在客户端使用它们。</li>
<li>这里的“可拓展”、“协同”对应到我们平时常说的，“跨语言”、“语言无关”。</li>
</ul>
</li>
<li>REST 用哪种 HTTP 方法呢?<ul>
<li>REST 能用任何的 HTTP 方法，但是，最受欢迎的是：<ul>
<li>用 GET 来检索服务端资源</li>
<li>用 POST 来创建服务端资源</li>
<li>用 PUT 来更新服务端资源</li>
<li>用 DELETE 来删除服务端资源。</li>
</ul>
</li>
</ul>
</li>
<li>删除的 HTTP 状态返回码是什么 ?<ul>
<li>在删除成功之后，您的 REST API 应该返回什么状态代码，并没有严格的规则。它可以返回 200 或 204 没有内容。<ul>
<li>一般来说，如果删除操作成功，响应主体为空，返回 204 。</li>
<li>如果删除请求成功且响应体不是空的，则返回 200 。</li>
</ul>
</li>
</ul>
</li>
<li>REST API 是无状态的吗?<ul>
<li>是的，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。</li>
<li>REST API 中的请求应该包含处理它所需的所有细节。它不应该依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</li>
</ul>
</li>
<li>REST安全吗? 你能做什么来保护它?<ul>
<li>REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。</li>
<li>至少，你可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。</li>
<li>类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。</li>
</ul>
</li>
<li>RestTemplate 的优势是什么?<ul>
<li>在 Spring Framework 中，RestTemplate 类是 模板方法模式 的实现。跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，它将在客户端简化跟 RESTful Web 服务的集成。正如在 RestTemplate 例子中显示的一样，你能非常容易地用它来调用 RESTful Web 服务。</li>
<li>实际场景我还是更喜欢使用 OkHttp 作为 HTTP 库，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。</li>
</ul>
</li>
<li>HttpMessageConverter 在 Spring REST 中代表什么?<ul>
<li>HttpMessageConverter 是一种策略接口 ，它指定了一个转换器，它可以转换 HTTP 请求和响应。Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。</li>
<li>每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。Spring 使用 “Accept” 的标头来确定客户端所期待的内容类型。</li>
<li>然后，它将尝试找到一个注册的 HTTPMessageConverter ，它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。</li>
</ul>
</li>
<li>@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用<ul>
<li>@PathVariable 注解，是 Spring MVC 中有用的注解之一，它允许您从 URI 读取值，比如查询参数。它在使用 Spring 创建 RESTful Web 服务时特别有用，因为在 REST 中，资源标识符是 URI 的一部分。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-MyBatis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/MyBatis/"
    >MyBatis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/MyBatis/" class="article-date">
  <time datetime="2021-11-07T02:52:28.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ol>
<li><p>MyBatis 编程步骤</p>
<ul>
<li>创建 SqlSessionFactory 对象。</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象。</li>
<li>通过 SqlSession 获得 Mapper 代理对象。</li>
<li>通过 Mapper 代理对象，执行数据库操作。</li>
<li>执行成功，则使用 SqlSession 提交事务。</li>
<li>执行失败，则使用 SqlSession 回滚事务。</li>
<li>最终，关闭会话。</li>
</ul>
</li>
<li><p>#{} 和 ${} 的区别是什么？</p>
<ul>
<li>${} 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于字符串替换,#{} 是预编译处理，可以有效防止 SQL 注入，提高系统安全性</li>
<li>${} 也可以对传递进来的参数原样拼接在 SQL 中,可能有 SQL 注入的风险。</li>
</ul>
</li>
<li><p>当实体类中的属性名和表中的字段名不一样 ，怎么办？</p>
<ul>
<li>在查询的 SQL 语句中定义字段名的别名</li>
<li>配置自动的下划线转驼峰的功能</li>
<li>通过 <resultMap> 来映射字段名和实体类属性名的一一对应的关系</li>
</ul>
</li>
<li><p>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</p>
<ul>
<li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li>
<li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;、&lt;choose /&gt;、&lt;when /&gt;、&lt;otherwise /&gt;、&lt;trim /&gt;、&lt;where /&gt;、&lt;set /&gt;、&lt;foreach /&gt;、&lt;bind /&gt; </code>。</li>
<li>其执行原理为，使用 OGNL 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li>
</ul>
</li>
<li><p>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</p>
<ul>
<li>接口的全限名，就是映射文件中的 “namespace” 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 “id” 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。</li>
<li>另外，Mapper 接口的实现类，通过 MyBatis 使用 JDK Proxy 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850110187997.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) 方法，代码如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得 MappedStatement 对象</span></span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</p>
<ul>
<li>通过 XML Mapper 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 “namespace” 必须为接口的全路径名。</li>
<li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update、@Insert、@Delete 注解，里面包含 SQL 语句来绑定。</li>
<li>是第二种的特例，也是通过注解绑定，在接口的方法上面加上 @SelectProvider、@UpdateProvider、@InsertProvider、@DeleteProvider 注解，通过 Java 代码，生成对应的动态 SQL </li>
</ul>
</li>
<li><p>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</p>
<ul>
<li>不同的 XML Mapper 文件，如果配置了 “namespace” ，那么 id 可以重复；如果没有配置 “namespace” ，那么 id 不能重复。毕竟”namespace” 不是必须的，只是最佳实践而已。</li>
<li>原因就是，namespace + id 是作为 Map&lt;String, MappedStatement&gt; 的 key 使用的。如果没有 “namespace”，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 “namespace”，自然 id 就可以重复，”namespace”不同，namespace + id 自然也就不同。</li>
</ul>
</li>
<li><p>如何获取自动生成的(主)键值?</p>
<ul>
<li>Mysql 自增主键<ul>
<li>使用 useGeneratedKeys + keyProperty 属性  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO person(name, pswd)</span><br><span class="line">        VALUE (#&#123;name&#125;, #&#123;pswd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    ```    </span><br><span class="line">- 使用 `<span class="tag">&lt;<span class="name">selectKey</span> /&gt;</span>` 标签</span><br><span class="line"></span><br><span class="line">    ```xml</span><br><span class="line">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br><span class="line">            INSERT INTO person(name, pswd)</span><br><span class="line">            VALUE (#&#123;name&#125;, #&#123;pswd&#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>            </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Oracle序列自增  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;student_id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        select student_sequence.nextval FROM dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO student(student_id, student_name, student_age)</span><br><span class="line">    VALUES (#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Mybatis 执行批量插入，能返回数据库主键列表吗？</p>
<ul>
<li>能，JDBC 都能做，Mybatis 当然也能做。</li>
</ul>
</li>
<li><p>MyBatis 如何执行批量插入?</p>
<ul>
<li>单条插傻循环</li>
<li>拼接insert into values (),(),();</li>
<li>使用BatchExecutor批处理</li>
</ul>
</li>
<li><p>在 Mapper 中如何传递多个参数?</p>
<ul>
<li>使用 Map 集合，装载多个参数进行传递</li>
<li>保持传递多个参数，使用 @Param 注解</li>
<li>保持传递多个参数，不使用 @Param 注解，#{param2}</li>
<li>使用对象定义VO，装载多个参数进行传递</li>
</ul>
</li>
<li><p>Mybatis 是否可以映射 Enum 枚举类？</p>
<ul>
<li>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。<ul>
<li>EnumTypeHandler ，基于 Enum.name 属性( String )。默认。</li>
<li>EnumOrdinalTypeHandler ，基于 Enum.ordinal 属性( int )。可通过 <setting name="defaultEnumTypeHandler" value="EnumOrdinalTypeHandler" /> 来设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</p>
<ul>
<li>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。<ul>
<li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找缓存的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 Map&lt;String, Statement&gt; 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。实际上，整个过程与 JDBC 批处理是相同。</li>
<li>CachingExecutor ：在上述的三个执行器之上，增加二级缓存的功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</p>
<ul>
<li><p>一级缓存：</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850119544106.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
</li>
<li><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户</p>
</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15850120537632.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</li>
<li>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<ul>
<li>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是一对一，collection 指的就是一对多查询。</li>
<li>在 Mybatis 配置文件中，可以配置 <setting name="lazyLoadingEnabled" value="true" /> 来启用延迟加载的功能。默认情况下，延迟加载的功能是关闭的。</li>
<li>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 a.getB().getName() 方法，进入拦截器的 invoke(…) 方法，发现 a.getB() 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用a.setB(b) 方法，于是 a 对象 b 属性就有值了，接着完成a.getB().getName() 方法的调用。这就是延迟加载的基本原理。</li>
</ul>
</li>
<li><p>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</p>
<ul>
<li>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</li>
<li>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 #invoke(…)方法。当然，只会拦截那些你指定需要拦截的方法。</li>
</ul>
</li>
<li><p>Mybatis 是如何进行分页的？分页插件的原理是什么？</p>
<ul>
<li>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非数据库分页</li>
<li>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</li>
<li>目前使用比较广泛的 MyBatis 分页插件有：Mybatis-PageHelper、MyBatis-Plus</li>
</ul>
</li>
<li><p>MyBatis 与 Hibernate 有哪些不同？</p>
<ul>
<li>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大</li>
<li>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行</li>
</ul>
</li>
<li><p>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</p>
<ul>
<li>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。<ul>
<li>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</li>
</ul>
</li>
<li>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul>
<li>解决方式：MyBatis 提供 <where />、<if /> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</li>
</ul>
</li>
<li>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。<ul>
<li>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</p>
<ul>
<li>虽然 Mybatis 解析 XML 映射文件是按照顺序解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。也就是说，无需按照顺序，进行定义。</li>
<li>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li>
</ul>
</li>
<li><p>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</p>
<ul>
<li>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</li>
<li>在 XML Mapper 文件中：<ul>
<li><parameterMap> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li>
<li><resultMap> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li>
<li>每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ORM/" rel="tag">ORM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Nginx"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/Nginx/"
    >Nginx</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/Nginx/" class="article-date">
  <time datetime="2021-11-07T02:51:33.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ol>
<li><p>请解释一下什么是 Nginx ？</p>
<ul>
<li>Nginx ，是一个 Web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>
<li>作为 http server</li>
<li>反向代理服务器</li>
<li>正向代理</li>
<li>实现负载均衡</li>
</ul>
</li>
<li><p>Nginx 常用命令？</p>
<ul>
<li>启动 nginx 。</li>
<li>停止 nginx -s stop 或 nginx -s quit 。</li>
<li>重载配置 ./sbin/nginx -s reload(平滑重启) 或 service nginx reload 。</li>
<li>重载指定配置文件 .nginx -c /usr/local/nginx/conf/nginx.conf 。</li>
<li>查看 nginx 版本 nginx -v 。</li>
<li>检查配置文件是否正确 nginx -t 。</li>
<li>显示帮助信息 nginx -h 。</li>
</ul>
</li>
<li><p>Nginx 常用配置？</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  8; # 工作进程个数</span><br><span class="line">worker_connections  65535; # 每个工作进程能并发处理（发起）的最大连接数（包含所有连接数）</span><br><span class="line"># 错误日志打印地址</span><br><span class="line">error_log         /data/logs/nginx/error.log;</span><br><span class="line"># 访问日志打印地址 </span><br><span class="line">access_log      /data/logs/nginx/access.log; </span><br><span class="line"># 日志格式</span><br><span class="line">log_format  main  &#x27;$remote_addr&quot;$request&quot; &#x27;&#x27;$status $upstream_addr &quot;$request_time&quot;&#x27;; </span><br><span class="line">listen       80; # 监听端口</span><br><span class="line"># 允许域名</span><br><span class="line">server_name  rrc.test.jiedaibao.com; </span><br><span class="line"># 项目根目录</span><br><span class="line">root  /data/release/rrc/web; </span><br><span class="line"># 访问根文件</span><br><span class="line">index  index.php index.html index.htm; </span><br></pre></td></tr></table></figure></li>
<li><p>Nginx 日志格式中的<code>$time_local</code>表示的是什么时间？请求开始的时间？请求结束的时间？其次，当我们从前到后观察日志中的 $time_local 时间时，有时候会发现时间顺序前后错乱的现象，请说明原因？</p>
<ul>
<li><code>$time_local</code> ：在服务器里请求开始写入本地的时间。</li>
<li>因为请求发生时间有前有后，所以会时间顺序前后错乱。</li>
</ul>
</li>
<li><p>Nginx 有哪些优点？</p>
<ul>
<li>跨平台、配置简单。</li>
<li>非阻塞、高并发连接</li>
<li>内存消耗小</li>
<li>成本低廉，且开源。</li>
<li>稳定性高，宕机的概率非常小。</li>
</ul>
</li>
<li><p>使用“反向代理服务器”的优点是什么？</p>
<ul>
<li>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 Web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当我们使用 Web 托管服务时。</li>
</ul>
</li>
<li><p>什么是正向代理？</p>
<ul>
<li>一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</li>
<li>客户端才能使用正向代理。</li>
<li>正向代理总结就一句话：代理端代理的是客户端</li>
</ul>
</li>
<li><p>什么是反向代理？</p>
<ul>
<li>反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
<li>反向代理总结就一句话：代理端代理的是服务端。</li>
</ul>
</li>
<li><p>LVS、Nginx、HAproxy 有什么区别？</p>
<ul>
<li>LVS ：是基于四层的转发。</li>
<li>HAproxy ： 是基于四层和七层的转发，是专业的代理服务器。</li>
<li>Nginx ：是 WEB 服务器，缓存服务器，又是反向代理服务器，可以做七层的转发。 <ul>
<li>Nginx 引入 TCP 插件之后，也可以支持四层的转发。</li>
</ul>
</li>
</ul>
</li>
<li><p>请解释 Nginx 如何处理 HTTP 请求？</p>
<ul>
<li>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 S ocket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</li>
<li>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</li>
<li>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</li>
<li>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</li>
<li>Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</li>
</ul>
</li>
<li><p>什么是动态资源、静态资源分离？</p>
<ul>
<li>动态资源、静态资源分离，是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</li>
<li>动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离。</li>
</ul>
</li>
<li><p>为什么要做动、静分离？</p>
<ul>
<li>在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件</li>
<li>因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗？当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决动、静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问</li>
<li>这里我们将静态资源放到 Nginx 中，动态资源转发到 Tomcat 服务器中去。 </li>
<li>因为现在七牛、阿里云等 CDN 服务已经很成熟，主流的做法，是把静态资源缓存到 CDN 服务中，从而提升访问速度。<ul>
<li>相比本地的 Nginx 来说，CDN 服务器由于在国内有更多的节点，可以实现用户的就近访问。</li>
<li>并且，CDN 服务可以提供更大的带宽，不像我们自己的应用服务，提供的带宽是有限的。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么叫 CDN 服务？</p>
<ul>
<li>CDN ，即内容分发网络。</li>
<li>其目的是，通过在现有的 Internet中 增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度。</li>
<li>一般来说，因为现在 CDN 服务比较大众，所以基本所有公司都会使用 CDN 服务。</li>
</ul>
</li>
<li><p>Nginx 有哪些负载均衡策略？</p>
<ul>
<li><p>轮询（默认）round_robin：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>
</li>
<li><p>IP 哈希 ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。当然，实际场景下，一般不考虑使用 ip_hash 解决 session 共享。</p>
</li>
<li><p>最少连接 least_conn：下一个请求将被分派到活动连接数量最少的服务器</p>
</li>
<li><p>权重</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight=1; # (weight 默认为1.weight越大，负载的权重就越大)</span><br><span class="line">down; # (down 表示单前的server暂时不参与负载)</span><br><span class="line">backup; # (其它所有的非backup机器down或者忙的时候，请求backup机器)</span><br><span class="line">max_fails=1; # 允许请求失败的次数默认为 1 。当超过最大次数时，返回</span><br><span class="line">proxy_next_upstream 模块定义的错误</span><br><span class="line">fail_timeout=30; # max_fails 次失败后，暂停的时间</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Nginx 如何实现后端服务的健康检查？</p>
<ul>
<li>利用 nginx 自带模块 ngx_http_proxy_module 和 ngx_http_upstream_module 对后端节点做健康检查。</li>
<li>利用 nginx_upstream_check_module 模块对后端节点做健康检查。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/Java%E5%9F%BA%E7%A1%80/"
    >Java基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-11-07T02:50:47.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java核心基础"><a href="#Java核心基础" class="headerlink" title="Java核心基础"></a>Java核心基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><p>JAVA基本数据类型所占长度、</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32bit</td>
<td>-2^31</td>
<td>+2^32 -1</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>-2^15</td>
<td>+2^15 -1</td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td>-128</td>
<td>+127</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>-2^63</td>
<td>+2^63 -1</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>Unicode 0</td>
<td>Unicode 2^16 -1</td>
</tr>
<tr>
<td>boolean</td>
<td>1bit</td>
<td>—-</td>
<td>—-</td>
</tr>
</tbody></table>
<ul>
<li>JAVA基本数据类型的长度是平台无关的，32位系统和64位系统一样，因为JAVA是运行在JVM上的。</li>
</ul>
</li>
<li><p>Java String 占用内存大小分析</p>
<ul>
<li>Java 对象在虚拟机的结构如下：<ul>
<li>对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）</li>
<li>Java 原始类型数据：如 int, float, char 等类型的数据</li>
<li>引用（reference）：4 个字节</li>
<li>填充符（padding）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><ol>
<li>什么是线程？<ul>
<li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位</li>
</ul>
</li>
<li>线程和进程有什么区别？<ul>
<li>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据</li>
</ul>
</li>
<li>如何在Java中实现线程？<ul>
<li>继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程</li>
</ul>
</li>
<li>用Runnable还是Thread？<ul>
<li>Runnable可以继承其他类</li>
</ul>
</li>
<li>Thread 类中的start() 和 run() 方法有什么区别？<ul>
<li>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当<strong>调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程</strong></li>
</ul>
</li>
<li>Java中Runnable和Callable有什么不同？<ul>
<li>Callable的 call() 方法有返回值和抛出异常，而Runnable的run()方法没有这些功能。</li>
<li>Callable可以返回装载有计算结果的Future对象。</li>
</ul>
</li>
<li>什么是线程安全？Vector是一个线程安全类吗？<ul>
<li>多线程操作下数据一致性</li>
</ul>
</li>
</ol>
<h2 id="ThreadLocal-相关"><a href="#ThreadLocal-相关" class="headerlink" title="ThreadLocal 相关"></a>ThreadLocal 相关</h2><ol>
<li>作为线程局部变量使用</li>
<li><code>set(T value)</code>:获取<code>ThreadLocalMap</code>(静态内部类)并保存value,为空则调用<code>createMap(Thread t, T firstValue)</code>;</li>
<li><code>getMap(Thread t)</code>:获取<code>ThreadLocalMap</code>,不为空则获取对应值;为空调用<code>setInitialValue()</code> 初始化value;内部调用<code>initialValue()</code>;</li>
<li>需要初始化值,要重写<code>initialValue</code></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/sonny543/article/details/51336457">threadlocal原理及常用应用场景</a></li>
</ol>
<h2 id="java-集合框架-队列相关"><a href="#java-集合框架-队列相关" class="headerlink" title="java 集合框架 队列相关"></a>java 集合框架 队列相关</h2><ol>
<li>HashMap <ul>
<li>基于Hash表的非同步实现,允许K-V 为null;</li>
<li>底层基于数组实现(HashMap.Entry[]),单项为一个链表</li>
<li>HashMap.Entry 包含K,V,next Entry&lt;K,V&gt;,hash</li>
<li>put(K,V) 通过hash(key.hashCode())计算出hash值决定其在数组中的存储位置，如果此位置上有对象的话，再去使用 equals方法进行比较，如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面</li>
<li>get(K) 首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</li>
<li>当hash冲突很多时，HashMap退化成链表。</li>
<li>key为null时，都放到table[0]</li>
<li>扩容默认负载因子0.75,重新计算位置单个Entry在新数组中的位置 (resize)</li>
<li>fast-fail volatile modCount</li>
<li>java 8 HashMap 改为 数组+链表/红黑树,同一hash位下链表元素&gt;=8时,链表转换为红黑树</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</li>
<li><font color="red" >待补充源码及具体实现</font></li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键</li>
<li>重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表</li>
</ul>
</li>
<li>HashSet<ul>
<li>HashSet由哈希表支持,基于HashMap实现，不保证set的迭代顺序，并允许使用null元素。</li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同。</li>
</ul>
</li>
<li>ArrayList<ul>
<li>ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。底层使用数组实现</li>
<li>该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的<font color="red">1.5倍</font>，这种操作的代价很高。</li>
<li>采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li>
</ul>
</li>
<li>LinkedList<ul>
<li>LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。</li>
<li>底层的数据结构是基于双向链表的，该数据结构我们称为节点(Node)</li>
<li>双向链表节点对应的静态内部类Node<E>的实例，Node中包含成员变量：next，prev，item。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/Spring/"
    >Spring</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/Spring/" class="article-date">
  <time datetime="2021-11-07T02:49:27.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-整体相关的面试"><a href="#Spring-整体相关的面试" class="headerlink" title="Spring 整体相关的面试"></a>Spring 整体相关的面试</h2><ol>
<li>什么是 Spring Framework？<ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</li>
</ul>
</li>
<li>Spring Framework 中有多少个模块，它们分别是什么？<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849299427756.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>Spring 核心容器:核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>Spring Context:Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。</li>
<li>SpEL (Spring Expression Language):Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2 中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置 Bean 定义。</li>
</ul>
</li>
<li>数据访问:Data Access 。<ul>
<li>JDBC: Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</li>
<li>ORM: Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</li>
<li>Transaction:Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。</li>
</ul>
</li>
<li>Web: 提供了创建 Web 应用程序的支持。它包含以下模块：<ul>
<li>WebMVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
<li>WebFlux:基于 Reactive 库的响应式的 Web 开发框架</li>
<li>WebSocket:Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</li>
<li>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</li>
</ul>
</li>
<li>AOP:支持面向切面编程。它包含以下模块：<ul>
<li>AOP通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</li>
<li>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
</ul>
</li>
<li>JMS</li>
<li>Test</li>
<li>Messaging</li>
</ul>
</li>
<li>使用 Spring 框架能带来哪些好处？<ul>
<li>DI ：依赖注入，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li>轻量级：与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li>面向切面编程(AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li>集成主流框架：Spring 并没有闭门造车，Spring 集成了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照模块的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>便捷的测试：要 测试一项用Spring开发的应用程序 十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>Web 框架：Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li>事务管理：Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
</ul>
</li>
<li>Spring 框架中都用到了哪些设计模式？<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 RestTemplate、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
</li>
</ol>
<h2 id="Spring-IoC-相关的面试题"><a href="#Spring-IoC-相关的面试题" class="headerlink" title="Spring IoC 相关的面试题"></a>Spring IoC 相关的面试题</h2><ol>
<li>什么是 Spring IoC 容器？<pre><code> - ![](https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849306616719.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10)
</code></pre>
<ul>
<li>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。<ul>
<li>Spring 容器使用依赖注入来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的配置元数据 Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</li>
</ul>
</li>
</ul>
</li>
<li>什么是依赖注入？<ul>
<li>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
</li>
<li>IoC 和 DI 有什么区别？<ul>
<li> IOC就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系；容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</li>
<li> DI应用程序依赖容器创建并注入它所需要的外部资源；</li>
</ul>
</li>
<li>可以通过多少种方式完成依赖注入？<ul>
<li>可以通过多少种方式完成依赖注入？<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
</li>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
</li>
<li>Spring 中有多少种 IoC 容器？<ul>
<li>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext <ul>
<li>BeanFactory：spring-beans 项目提供，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</li>
<li>ApplicationContext：接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
<li>常用WebApplicationContext ClassPathXmlApplicationContext</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>请介绍下常用的 BeanFactory 容器？<ul>
<li>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</li>
<li>ListableBeanFactory:实现了枚举方法可以列举出当前 BeanFactory 中所有的 bean 对象而不必根据 name 一个一个的获取。</li>
</ul>
</li>
<li>请介绍下常用的 ApplicationContext 容器？<ul>
<li>ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：<pre><code>  ```java ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);``` 
</code></pre>
</li>
<li>FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：<pre><code>  ```java ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”); ```
</code></pre>
</li>
<li>Spring Boot 使用的是ConfigServletWebServerApplicationContext ApplicationContext 容器，。</li>
</ul>
</li>
<li>列举一些 IoC 的一些好处？<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
</li>
<li>简述 Spring IoC 的实现机制？<ul>
<li>Spring 中的 IoC 的实现原理，就是工厂模式加反射机制</li>
</ul>
</li>
</ol>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><ol>
<li><p>什么是 Spring Bean ？</p>
<ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
</li>
<li><p>Spring 有哪些配置Bean的方式</p>
<ul>
<li>XML 配置文件。</li>
<li>注解配置。</li>
<li>Java Config 配置，使用 @Bean 和 @Configuration 来实现。</li>
<li>具体举例<ul>
<li>Dubbo 服务的配置，使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 @RequestMapping 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
<li>Spring Boot 以Java Config 配置为主。</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring 支持几种 Bean Scope ？</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。默认</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
</li>
<li><p>Spring Bean 在容器的生命周期是什么样的？</p>
<ul>
<li>Spring Bean 的初始化流程如下：<ul>
<li>实例化 Bean 对象<ul>
<li>Spring 容器根据配置中的 Bean Definition(定义)中实例化 Bean 对象。(Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供)。</li>
<li>Spring 使用依赖注入填充所有属性，如 Bean 中所定义的配置。</li>
</ul>
</li>
<li>Aware 相关的属性，注入到 Bean 对象<ul>
<li>如果 Bean 实现 BeanNameAware 接口，则工厂通过传递 Bean 的 beanName 来调用 #setBeanName(String name) 方法。</li>
<li>如果 Bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 #setBeanFactory(BeanFactory beanFactory) 方法。</li>
</ul>
</li>
<li>调用相应的方法，进一步初始化 Bean 对象<ul>
<li>如果存在与 Bean 关联的任何 BeanPostProcessor 们，则调用 #preProcessBeforeInitialization(Object bean, String beanName) 方法。</li>
<li>如果 Bean 实现 InitializingBean 接口，则会调用 #afterPropertiesSet() 方法。</li>
<li>如果为 Bean 指定了 init 方法（例如 <bean /> 的 init-method 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 BeanPostProcessor 们，则将调用 #postProcessAfterInitialization(Object bean, String beanName) 方法。</li>
</ul>
</li>
</ul>
</li>
<li>Spring Bean 的销毁流程如下：<ul>
<li>如果 Bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 #destroy() 方法。</li>
<li>如果为 bean 指定了 destroy 方法（例如 <bean /> 的 destroy-method 属性），那么将调用该方法。<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849331702416.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是 Spring 装配？</p>
<ul>
<li>装配，和上文提到的 DI 依赖注入，实际是一个东西。</li>
</ul>
</li>
<li><p>自动装配有哪些方式？</p>
<ul>
<li>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</li>
<li>自动装配的不同模式：<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
</li>
</ul>
</li>
<li><p>解释什么叫延迟加载？</p>
<ul>
<li>默认情况下，容器启动之后会将所有作用域为单例的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 lzay-init = “true” 。</li>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
</li>
<li><p>Spring 框架中的单例 Bean 是线程安全的么？</p>
<ul>
<li>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。</li>
</ul>
</li>
<li><p>Spring Bean 怎么解决循环依赖的问题？</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849337079754.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
</li>
<li><p>Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中）。</p>
</li>
<li><p>这样，一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 #getObject() 方法来获取了。</p>
</li>
<li><p>实例如 A 依赖 B，B 依赖 C，C 依赖 A：</p>
<ul>
<li>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来</li>
<li>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来</li>
<li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中</li>
<li>回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了</li>
</ul>
</li>
</ul>
</li>
<li><p>BeanFactory和FactoryBean的区别</p>
<ul>
<li>BeanFactory是个Factory，也就是IOC容器或对象工厂</li>
<li>FactoryBean是个Bean。</li>
<li>Spring中所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 <h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2></li>
</ul>
</li>
<li><p>什么是基于注解的容器配置？</p>
<ul>
<li>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案</li>
<li>以Java Config 配置Bean的方式。</li>
</ul>
</li>
<li><p>如何在 Spring 中启动注解装配？</p>
<ul>
<li><code>&lt;context：annotation-config /&gt;</code></li>
<li>Spring Boot默认情况下已经开启。</li>
</ul>
</li>
<li><p>@Component, @Controller, @Repository, @Service 有何区别？</p>
<ul>
<li>@Component ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的通用构造型。</li>
<li>@Controller ：它将一个类标记为 Spring Web MVC 控制器。</li>
<li>@Service ：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component ，因为它以更好的方式指定了意图。</li>
<li>@Repository ：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
</li>
<li><p>@Required 注解有什么用？</p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
</li>
<li><p>@Autowired 注解有什么用？</p>
<ul>
<li>@Autowired 注解，可以更准确地控制应该在何处以及如何进行自动装配。<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
</li>
</ul>
</li>
<li><p>@Qualifier 注解有什么用？</p>
<ul>
<li>当你创建多个相同类型的 Bean ，并希望仅使用属性装配其中一个 Bean 时，您可以使用 @Qualifier 注解和 @Autowired 通过指定 ID 应该装配哪个确切的 Bean 来消除歧义。</li>
</ul>
</li>
<li><p>@Autowired注解与@Resource注解的区别</p>
<ul>
<li>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</li>
<li>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)</li>
<li>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li>
<li>@Resource装配顺序：<ul>
<li>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>
<li>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li>
<li>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li>
<li>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ol>
<li>什么是 AOP ？<ul>
<li>AOP(Aspect-Oriented Programming)，即面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</li>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以切面( Aspect )作为基本单元。</li>
</ul>
</li>
<li>什么是 Aspect ？<ul>
<li>Aspect 由 PointCut 和 Advice 组成,@Aspect 注解的类就是切面。<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
<li>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<ul>
<li>如何通过 PointCut 和 Advice 定位到特定的 JoinPoint 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>什么是 JoinPoint ?<ul>
<li>JoinPoint ，切点，程序运行中的一些时间点, 例如：<ul>
<li> 一个方法的执行。</li>
<li> 或者是一个异常的处理。</li>
</ul>
</li>
<li> 在 Spring AOP 中，JoinPoint 总是方法的执行点。</li>
</ul>
</li>
<li>什么是 PointCut ？<ul>
<li>PointCut 是匹配 JoinPoint 的条件。</li>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 Advice =&gt; PointCut =&gt; JoinPoint 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。而 PointCut 的作用，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
</li>
<li>关于 JoinPoint 和 PointCut 的区别<ul>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ul>
</li>
<li>什么是 Advice ？<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</li>
</ul>
</li>
<li>有哪些类型的 Advice？<ul>
<li>1.@Before前置通知在切入点运行前执行，不会影响切入点的逻辑</li>
<li>2.@After后置通知在切入点正常运行结束后执行，如果切入点抛出异常，则在抛出异常前执行</li>
<li>3.@AfterThrowing异常通知:在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行</li>
<li>4.@AfterReturning返回通知:在切入点正常运行结束后执行，如果切入点抛出异常，则不执行</li>
<li>5.@Around环绕通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行</li>
</ul>
</li>
<li>什么是 Target ？<ul>
<li>Target ，织入 Advice 的目标对象。目标对象也被称为 Advised Object 。<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
</li>
</ul>
</li>
<li>AOP 有哪些实现方式？<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。<ul>
<li>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
</li>
<li>Spring 如何使用 AOP 切面？<ul>
<li>基于 XML 方式的切面实现。</li>
<li>基于 注解 方式的切面实现。</li>
</ul>
</li>
</ol>
<h2 id="Spring-Transaction-相关的面试题"><a href="#Spring-Transaction-相关的面试题" class="headerlink" title="Spring Transaction 相关的面试题"></a>Spring Transaction 相关的面试题</h2><ol>
<li>列举 Spring 支持的事务管理类型？<ul>
<li>声明式事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li>编程式事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
</li>
<li>Spring 事务如何和不同的数据持久层框架做集成？<ul>
<li>Spring 事务的管理，是通过org.springframework.transaction.PlatformTransactionManager 进行管理<ul>
<li>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。<ul>
<li><code>getTransaction(TransactionDefinition definition)</code> 方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。<ul>
<li>为什么不是创建事务？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。</li>
<li>为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。</li>
</ul>
</li>
<li><code>commit(TransactionStatus status)</code> 方法，根据 TransactionStatus 情况，提交事务。<ul>
<li>为什么根据 TransactionStatus 情况，进行提交？<ul>
<li>例如，带@Transactional 注解的的 A 方法，会调用 @Transactional 注解的的 B 方法。</li>
<li>在 B 方法结束调用后，会执行 PlatformTransactionManager#commit(TransactionStatus status) 方法，此处事务是不能、也不会提交的。</li>
<li>而是在 A 方法结束调用后，执行 PlatformTransactionManager#commit(TransactionStatus status) 方法，提交事务。</li>
</ul>
</li>
</ul>
</li>
<li><code>rollback(TransactionStatus status)</code> 方法，根据 TransactionStatus 情况，回滚事务。<ul>
<li>为什么根据 TransactionStatus 情况，进行回滚？原因同 #commit(TransactionStatus status) 方法。</li>
</ul>
</li>
</ul>
</li>
<li>PlatformTransactionManager 有抽象子类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 模板方法模式 ，实现事务整体逻辑的骨架，而抽象 <code>doCommit(DefaultTransactionStatus status)</code>、<code>doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现</li>
<li>不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849356731423.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。</li>
<li>HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。</li>
<li>DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。</li>
<li>JpaTransactionManager ，和 JPA 的事务管理做集成。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为什么在 Spring 事务中不能切换数据源？<ul>
<li>在 Spring 的事务管理中，所使用的数据库连接会和当前线程所绑定，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</li>
<li>多个数据源且需要事务的场景，本身会带来多事务一致性的问题，暂时没有特别好的解决方案。</li>
<li>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</li>
</ul>
</li>
<li>@Transactional 注解有哪些属性？如何使用？<ul>
<li>@Transactional 注解的属性如下：<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<ul>
<li>具体用法如下：<ul>
<li>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
<li>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。这一点，非常需要注意。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>什么是事务的传播级别？分成哪些传播级别？<ul>
<li>事务的传播行为，指的是当前带有事务配置的方法，需要怎么处理事务。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========== 支持当前事务的情况 ========== </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 不支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的事务。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 其他情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则等价于 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_REQUIRED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>什么是事务的超时属性？<ul>
<li>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</li>
</ul>
</li>
<li>什么是事务的只读属性？<ul>
<li>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</li>
<li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li>
<li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。</li>
</ul>
</li>
<li>什么是事务的回滚规则？<ul>
<li>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</li>
<li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。</li>
<li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li>
<li>注意，事务的回滚规则，并不是数据库事务规范中的名词，而是 Spring 自身所定义的。</li>
</ul>
</li>
<li>简单介绍 TransactionStatus ？ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionStatus.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是新创建的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有 Savepoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 flush 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否事务已经完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 Object transaction 属性，表示事务对象。</li>
<li>isNewTransaction() 方法，表示是否是新创建的事务。有什么用呢？答案结合 「Spring 事务如何和不同的数据持久层框架做集成？」 问题，我们对 commit(TransactionStatus status) 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，才能且应该真正的提交事务。</li>
</ul>
</li>
<li>使用 Spring 事务有什么优点？<ul>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-JVM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/JVM/"
    >JVM</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/JVM/" class="article-date">
  <time datetime="2021-11-07T02:47:01.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol>
<li><p>JVM 由哪些部分组成？</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847504847911.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847532504574.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>类加载器：在JVM启动时或者类运行时将需要的class加载到JVM。</li>
<li>运行时数据区：将内存划分为若干个区以模拟实际机器上的存储，记录，调度功能模块。</li>
<li>执行引擎：执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU。</li>
<li>本地方法调用：调用 C 或 C++ 实现的本地方法的代码返回结果。</li>
</ul>
</li>
<li><p>JVM 运行内存（运行时数据区）的分类？</p>
<ul>
<li>程序计数器（线程私有）：记录正在执行的Java方法的字节码指令地址，唯一没有OutOfMemoryError情况的区域</li>
<li>栈内存（线程私有）：描述Java方法执行时的内存模型 <ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量，操作数，动态链接，方法出口等信息</li>
<li>每个方法调用都意味着一个栈帧再虚拟机栈中入栈到出栈的过程</li>
<li>局部变量表：基本数据类型（boolean,byte,short,int,long,float,double,char），对象引用（reference类型，不等同与对象，是指针或者资源地址），returnAddress类型（指向一条字节码指令的位置）</li>
<li>线程执行栈深度超出限制，跑出StackOverFlowError</li>
</ul>
</li>
<li>本地方法栈：<ul>
<li>和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务</li>
</ul>
</li>
<li>堆内存（线程共享）：所有线程共享的一块区域，存放对象实例，垃圾收集器管理的主要区域。<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
<li>可固定，可拓展通过-Xms -Xmx控制</li>
<li>堆内存无法分配内存，且无法拓展，抛出OutOfMemory</li>
</ul>
</li>
<li>方法区（线程共享）：主要用于已被虚拟机加载的类信息、静态变量、常量、JIT编译后的代码<ul>
<li>JDK 1.8 的对 JVM 架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到 Java 堆里</li>
<li>JDK 1.7 <code>java.lang.OutOfMemoryError: PermGen space</code> -XX:MaxPermSize -XX:PermSize</li>
<li>JDK 1.8 -XX:MetaspaceSize，初始空间大小;-XX:MaxMetaspaceSize，最大空间，默认是没有限制的</li>
<li>运行时常量池</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5309550.html">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>直接内存是不是虚拟机运行时数据区的一部分？</p>
<ul>
<li>直接内存(Direct Memory)不是虚拟机运行时数据区的一部分</li>
<li>使用 native 函数库直接分配堆外内存，使用Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据显著提高性能</li>
<li>本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。</li>
<li>配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。</li>
</ul>
</li>
<li><p>Java内存模型?</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15848403457744.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>定义程序中各个变量的访问规则</li>
<li>所有的变量都存储在主内存</li>
<li>线程有自己的工作内存，工作内存保存了该线程使用到的变量的主内存副本拷贝</li>
<li>线程间变量值的传递均需要通过主内存来实现</li>
<li>原子性: synchronized保证了原子性，提供了两个高级的字节码指令monitorenter和monitorexit</li>
<li>可见性：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。可以使用synchronized，volatile， final实现</li>
<li>有序性：在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性；volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</li>
</ul>
</li>
<li><p>直接内存（堆外内存）与堆内存比较？</p>
<ul>
<li>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。</li>
<li>直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</li>
</ul>
</li>
<li><p>为什么要废弃永久代？</p>
<ul>
<li>由于永久代内存经常不够用或发生内存泄露，爆出异常 java.lang.OutOfMemoryError: PermGen</li>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
</li>
<li><p>Java 内存堆和栈区别？</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847579303911.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>栈内存存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>栈溢出 java.lang.StackOverFlowError；堆溢出java.lang.OutOfMemoryError</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。-Xss 选项设置栈内存的大小，-Xms 选项可以设置堆的开始时的大小。</li>
</ul>
<blockquote>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
</blockquote>
</li>
<li><p>JAVA 对象创建的过程？</p>
<pre><code> - ![](https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847585045516.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10)                                                    
 - ![](https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847593821321.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10)        
</code></pre>
<ol>
<li>检测类是否被加载:当虚拟机遇到 new 指令时，首先先去检查这个指令的参数是否能在常量池(方法区-运行时常量池)中定位到一<strong>个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程</li>
<li>为对象分配内存：<ul>
<li>内存空间绝对规整：虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为“<strong>指针碰撞</strong>”。</li>
<li>内存不规整：虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为“<strong>空闲列表</strong>”。</li>
</ul>
</li>
<li>为分配的内存空间初始化零值：对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象的实例字段即使没有赋初值，也可以直接使用。</li>
<li>对对象进行其他设置：在对象头中设置对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。</li>
<li>执行 init 方法：Java 在编译之后会在字节码文件中生成 init 方法，称之为实例构造器，该实例构造器会将语句块，变量初始化，调用父类的构造器等操作收敛到 init 方法中，收敛顺序为：<ol>
<li>父类变量初始化</li>
<li>父类语句块</li>
<li>父类构造函数</li>
<li>子类变量初始化</li>
<li>子类语句块</li>
<li>子类构造函数</li>
</ol>
</li>
</ol>
</li>
<li><p>A a = new A() 经历过什么过程?</p>
<blockquote>
<p>同上</p>
</blockquote>
</li>
<li><p>对象的内存布局是怎样的？JAVA对象模型？</p>
<ul>
<li>对象头：对象头包括两部分信息。<ul>
<li>第一部分，是存储对象自身的运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁等等。</li>
<li>第二部分，是类型指针，即对象指向类元数据的指针。</li>
</ul>
</li>
<li>实例数据：对象真正存储的有效信息</li>
<li>对齐填充：不是必然的存在，就是为了对齐。</li>
</ul>
</li>
<li><p>对象是如何定位访问的？</p>
<ul>
<li>对象的访问定位有两种：<ol>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847606523598.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li>直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847606809648.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
</ol>
</li>
<li>对比两种方式？<ul>
<li>使用句柄来访问的最大好处，就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>有哪些 OutOfMemoryError 异常？</p>
<ul>
<li>除了程序计数器外，虚拟机内存的其它几个运行时区域都有发生的 OutOfMemoryError(简称为“OOM”) 异常的可能。</li>
<li>Java 堆溢出:不停new对象，保证GCRoot可达性</li>
<li>虚拟机栈和本地方法栈溢出：栈容量由 -Xss参数设定 递归</li>
<li>方法区和运行时常量池溢出 大量类<blockquote>
<p>从 JDK8 开始，就变成元数据区的内存溢出。</p>
</blockquote>
</li>
<li>元数据区的内存溢出:-XX:MaxMetaspaceSize=10m</li>
<li>本机直接内存溢出 申请对外内存</li>
</ul>
</li>
<li><p>当出现了内存溢出，怎么排错？</p>
<ol>
<li>首先，控制台查看错误日志。</li>
<li>使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。<code>jstat</code> <code>jmap</code></li>
<li>定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。<ol>
<li>如果是堆内存溢出，看是否创建了超大的对象。</li>
<li>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。</li>
</ol>
</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2fdee831ed03">Java内存溢出(OOM)异常完全指南</a></p>
</blockquote>
</li>
<li><p>Java 中会存在内存泄漏吗？</p>
<ul>
<li>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。</li>
<li>使用 Netty 的堆外的 ByteBuf 对象，在使用完后，并未归还，导致使用的一点一点在泄露。</li>
</ul>
</li>
</ol>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><ol>
<li><p>什么是垃圾回收机制？</p>
<ul>
<li>Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆(Heap)中分配的，所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成的。GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。</li>
<li>Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。</li>
<li>可以调用下面的方法之一：<code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> ，但 JVM 也可以屏蔽掉显示的垃圾回收调用。</li>
</ul>
</li>
<li><p>为什么不建议在程序中显式的声明 System.gc() ？</p>
<ul>
<li>因为显式声明是做堆内存全扫描，也就是 Full GC ，是需要停止所有的活动的(Stop The World Collection)，对应用很大可能存在影响。</li>
<li>调用 System.gc() 方法后，不会立即执行 Full GC ，而是虚拟机自己决定的。</li>
</ul>
</li>
<li><p>如果一个对象的引用被设置为 null , GC 会立即释放该对象的内存么?</p>
<ul>
<li>不会, 这个对象将会在下一次 GC 循环中被回收。</li>
</ul>
</li>
<li><p><code>finalize()</code> 方法什么时候被调用？它的目的是什么？</p>
<ul>
<li><code>finallize()</code>方法，是在释放该对象内存前由 GC (垃圾回收器)调用。</li>
<li><del>通常建议在这个方法中释放该对象持有的资源，例如持有的堆外内存、和远程服务的长连接。</del></li>
<li>对于一个对象，该方法有且仅会被调用一次。</li>
</ul>
</li>
<li><p>如何判断一个对象是否已经死去？</p>
<ul>
<li>引用计数<ul>
<li>每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。目前在用的有 Python、ActionScript3 等语言。</li>
</ul>
</li>
<li>可达性分析<ul>
<li>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。目前在用的有 Java、C# 等语言。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果 A 和 B 对象循环引用，是否可以被 GC？</p>
<ul>
<li>可以，因为 Java 采用可达性分析的判断方式。</li>
</ul>
</li>
<li><p>在 Java 语言里，可作为 GC Roots 的对象包括以下几种？</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。(参数)</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)中引用的对象。</li>
</ul>
</li>
<li><p>方法区是否能被回收？</p>
<ul>
<li>方法区可以被回收，但是价值很低，主要回收废弃的常量和无用的类。</li>
<li>如何判断无用的类，需要完全满足如下三个条件：<ul>
<li>该类所有实例都被回收（Java 堆中没有该类的对象）。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java 对象有哪些引用类型?</p>
<ul>
<li>强引用<ul>
<li>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</li>
</ul>
</li>
<li>软引用（SoftReference）<ul>
<li>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</li>
<li>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li><code>Mybatis SoftCache</code></li>
</ul>
</li>
<li>弱引用（WeakReference）<ul>
<li>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li>
<li>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li>
<li><code>Mybatis WeakCache</code></li>
</ul>
</li>
<li>虚引用（PhantomReference）<ul>
<li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li>
<li>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li>
</ul>
</li>
</ul>
</li>
<li><p>WeakReference 与 SoftReference的区别？</p>
<ul>
<li>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率。但是 WeakReference 一旦失去最后一个强引用，就会被 GC 回收而 SoftReference 虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</li>
</ul>
</li>
<li><p>为什么要有不同的引用类型？</p>
<ul>
<li>不像 C 语言，我们可以控制内存的申请和释放，在 Java 中有时候我们需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对 GC 回收时机不可控的妥协。有以下几个使用场景可以充分的说明：</li>
<li>利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题.</li>
<li>通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person 的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person 对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。</li>
</ul>
</li>
<li><p>JVM 垃圾回收算法？</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847757529717.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
</li>
<li><p>标记-清除算法</p>
<ul>
<li>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</li>
<li>一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。</li>
<li>缺点：<ol>
<li>效率问题，标记和清除两个过程的效率都不高。</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
</li>
</ul>
</li>
<li><p>标记-整理算法</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847758515877.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
</li>
<li><p>标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
</li>
<li><p>优点：</p>
<ol>
<li>相对标记清除算法，解决了内存碎片问题。</li>
<li>没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol start="3">
<li>效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。</li>
</ol>
</li>
</ul>
</li>
<li><p>复制算法</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847759518607.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。</li>
<li>图的上半部分是未回收前的内存区域，图的下半部分是回收后的内存区域。通过图，可以发现不管回收前还是回收后都有一半的空间未被利用。</li>
<li>优点：<ol start="4">
<li>效率高，没有内存碎片。</li>
</ol>
</li>
<li>缺点：<ol start="5">
<li>浪费一半的内存空间。</li>
<li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ol>
</li>
</ul>
</li>
<li><p>分代收集算法</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847762126339.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></p>
</li>
<li><p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</p>
</li>
<li><p>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。</p>
</li>
<li><p>而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</p>
</li>
<li><p>对象分配策略：</p>
<ul>
<li>对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。</li>
<li>长时间存活的对象进入到 Old 区域。</li>
</ul>
</li>
<li><p>改进自复制算法</p>
<ul>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</li>
<li>HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是安全点？</p>
<ul>
<li>SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap 的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。</li>
</ul>
</li>
<li><p>那些位置可以作为安全点</p>
<ul>
<li>循环的末尾 (防止大循环的时候一直不进入 Safepoint ，而其他线程在等待它进入 Safepoint )。</li>
<li>方法返回前。</li>
<li>调用方法的 Call 之后。</li>
<li>抛出异常的位置。</li>
</ul>
</li>
<li><p>GC发生时停止到安全点的方式</p>
<ul>
<li>主动式<ul>
<li> JVM 设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是 SafePoint 就主动挂起。轮询点==安全点</li>
<li> HostSpot 虚拟机采用的是主动式使线程中断。</li>
</ul>
</li>
<li>抢先式<ul>
<li>JVM发出信号，所有线程全部停止，检查非安全点的线程，让其恢复跑到安全点</li>
</ul>
</li>
<li>安全区域<ul>
<li>如果程序长时间不执行，比如线程调用的 sleep 方法，这时候程序无法响应 JVM 中断请求这时候线程无法到达安全点，显然 JVM 也不可能等待程序唤醒，这时候就需要安全区域了。</li>
<li>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方 GC 都是安全的，安全区域可以看做是安全点的一个扩展。</li>
<li>线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样 GC 时就不用管进入安全区域的线程了.</li>
<li>线程要离开安全区域时就检查 JVM 是否完成了 GC Roots 枚举（或者整个 GC 过程），如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。</li>
</ul>
</li>
</ul>
</li>
<li><p>JVM 垃圾收集器有哪些？</p>
<ul>
<li>新生代收集器<ul>
<li>Serial 收集器</li>
<li>ParNew 收集器<blockquote>
<p>ParNew 收集器，是 Serial 收集器的多线程版。</p>
</blockquote>
</li>
<li>Parallel Scavenge 收集器</li>
</ul>
</li>
<li>老年代收集器<ul>
<li>Serial Old 收集器<blockquote>
<p>Serial Old 收集器，是 Serial 收集器的老年代版本。</p>
</blockquote>
</li>
<li>Parallel Old 收集器<blockquote>
<p>Parallel Old 收集器，是 Parallel Scavenge 收集器的老年代版本。</p>
</blockquote>
</li>
<li>CMS 收集器</li>
</ul>
</li>
<li>新生代 + 老年代收集器<ul>
<li>G1 收集器</li>
<li>ZGC 收集器</li>
</ul>
</li>
<li>对比<table>
<thead>
<tr>
<th>收集器</th>
<th>串行/并行/并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>JDK默认的垃圾回收器?</p>
<ul>
<li>JDK1.7: Parallel Scavenge（新生代）+Parallel Old（老年代）</li>
<li>JDK1.8: Parallel Scavenge（新生代）+Parallel Old（老年代）</li>
<li>JDK1.9: G1</li>
<li>-XX:+PrintCommandLineFlagsjvm 看默认设置收集器类型</li>
<li>-XX:+PrintGCDetails 通过打印的GC日志的新生代、老年代名称判断</li>
</ul>
</li>
<li><p>G1 和 CMS 的区别？</p>
<ul>
<li>CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。</li>
<li>G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）</li>
<li>CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内存的大小有很大的要求。</li>
<li>CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。</li>
<li>G1 和 CMS 都是响应优先，他们的目的都是尽量控制 STW 时间。</li>
<li>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化为并行的。</li>
</ul>
</li>
<li><p>CMS 算法回收过程中 JVM 是否需要暂停？</p>
<ul>
<li>会有短暂的停顿</li>
</ul>
</li>
<li><p>如何使用指定的垃圾收集器</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UserSerialGC</td>
<td>串行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UserParrallelGC</td>
<td>并行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>并发标记扫描垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelCMSThreads</td>
<td>并发标记扫描垃圾回收器 =为使用的线程数量</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1垃圾回收器</td>
</tr>
</tbody></table>
</li>
<li><p>对象分配规则是什么？</p>
<ul>
<li><p><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847831931490.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10" alt="-w655"></p>
</li>
<li><p>对象优先分配在 Eden 区。</p>
<ul>
<li>如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）<ul>
<li>如果 Survivor0 可以放入，那么放入之后清除 Eden 区。</li>
<li>如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。<ul>
<li>如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。</li>
<li>如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为分配担保。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</p>
<ul>
<li>这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
</ul>
</li>
<li><p>长期存活的对象进入老年代。</p>
<ul>
<li>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区。</li>
</ul>
</li>
<li><p>动态判断对象的年龄。</p>
<ul>
<li>为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。</li>
<li>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
</ul>
</li>
<li><p>空间分配担保。</p>
<ul>
<li>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行  or GC ，如果 false 则进行 Full GC 。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么新生代内存需要有两个 Survivor 区？</p>
<ul>
<li>解决了碎片化</li>
<li>减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li>
</ul>
</li>
<li><p>什么是新生代 GC 和老年代 GC？</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847835594680.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10" alt="-w435"></li>
<li>默认新生代(Young)与老年代(Old)的比例的值为 1:2 (该值可以通过参数 –XX:NewRatio 来指定)。</li>
<li>默认的 Eden:from:to=8:1:1 (可以通过参数 –XX:SurvivorRatio 来设定)。</li>
<li>新生代GC（MinorGC/YoungGC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。</li>
<li>老年代GC（MajorGC/FullGC）：指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。</li>
</ul>
</li>
<li><p>什么情况下会出现 Young GC？</p>
<ul>
<li>对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。</li>
</ul>
</li>
<li><p>什么情况下回出现 Full GC？</p>
<ul>
<li>Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。<ul>
<li>在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。</li>
<li>大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。</li>
<li>显式调用 <code>System.gc()</code> 方法时。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h2><ol>
<li><p>JDK 的命令行工具有哪些可以监控虚拟机？</p>
<ul>
<li>jps ：虚拟机进程状况工具<ul>
<li>JVM Process Status Tool ，显示系统内所有的HotSpot虚拟机进程。</li>
</ul>
</li>
<li>jstat ：虚拟机统计信息监控工具<ul>
<li>JVM statistics Monitoring ，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li><code>jstat -gccause PID 1000</code></li>
</ul>
</li>
<li>jinfo ：Java 配置信息工具<ul>
<li>JVM Configuration info ，这个命令作用是实时查看和调整虚拟机运行参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK 的可视化工具有哪些可以监控虚拟机？</p>
<ul>
<li>JConsole对 JVM 中内存，线程和类等的监控。</li>
<li>VisualVM 可以分析内存快照、线程快照、监控内存变化、GC变化等。</li>
<li>JProfile</li>
<li>GC日志分析工具</li>
</ul>
</li>
<li><p>怎么获取 Java 程序使用的内存？</p>
<ul>
<li>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。<ul>
<li>Runtime.freeMemory() 方法，返回剩余空间的字节数。</li>
<li>Runtime.totalMemory() 方法，总内存的字节数。</li>
<li>Runtime.maxMemory() 方法，返回最大内存的字节数。</li>
</ul>
</li>
</ul>
</li>
<li><p>常见 GC 的优化配置？</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始化堆内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大值</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>初始化永久代大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久代最大容量</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置年轻代中 Eden 区与 Survivor 区的比值</td>
</tr>
<tr>
<td>-XX:Xmn</td>
<td>设置年轻代大小</td>
</tr>
</tbody></table>
</li>
<li><p>如何排查线程 Full GC 频繁的问题</p>
<ul>
<li>System.gc()方法的调用</li>
<li>老年代代空间不足</li>
<li>永生区空间不足</li>
<li>统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</li>
<li>堆中分配很大的对象</li>
</ul>
</li>
<li><p>类加载器是有了解吗？</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847900544255.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li><p>什么是双亲委派模型（Parent Delegation Model）？</p>
<ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15847901946443.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
<li>类加载器 ClassLoader 是具有层次结构的，也就是父子关系</li>
<li>Bootstrap ClassLoader ：根类加载器，负责加载 Java 的核心类，它不是 java.lang.ClassLoader 的子类，而是由 JVM 自身实现。</li>
<li>Extension ClassLoader ：扩展类加载器</li>
<li>Application ClassLoader ：系统(应用)类加载器</li>
<li>该模型要求除了顶层的 Bootstrap 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码</li>
</ul>
</li>
<li><p>Java 虚拟机是如何判定两个 Java 类是相同的？</p>
<ul>
<li>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</li>
</ul>
</li>
<li><p>双亲委派模型的工作过程？</p>
<ul>
<li>当前 ClassLoader 首先从自己已经加载的类中，查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</li>
<li>当前 ClassLoader 的缓存中没有找到被加载的类的时候<ul>
<li>委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。</li>
<li>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么优先使用父 ClassLoader 加载类？</p>
<ul>
<li>共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</li>
<li>隔离功能：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException 。  </li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >设计模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-11-07T02:45:29.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="设计模式-TODO"><a href="#设计模式-TODO" class="headerlink" title="设计模式(TODO)"></a>设计模式(TODO)</h1><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol>
<li>饿汉 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_Hunger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton_Hunger SINGLETON_HUNGER = <span class="keyword">new</span> Singleton_Hunger();</span><br><span class="line">    <span class="comment">//限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_Hunger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过该方法获得实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_Hunger <span class="title">getSingletonHunger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON_HUNGER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中其他方法，尽量是static</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>懒汉 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_Lazy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态实例变量加上volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检查锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton_Lazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton_Lazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态内部类(懒汉) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用静态内部类特性实现外部类的单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用静态内部类特性实现外部类的单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonBuilder.singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleTon instance = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>枚举实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用静态内部类特性实现外部类的单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    ONE , TWO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
</li>
<li><p>主要解决：主要解决接口选择的问题。</p>
</li>
<li><p>实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><h2 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h2><h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><h2 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h2><h2 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h2><h2 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h2><h2 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h2><h2 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Redis面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"
    >Redis面试题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2021-11-07T02:44:00.000Z" itemprop="datePublished">2021-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol>
<li>什么是 Redis ？<ul>
<li>Redis是一个基于内存的高性能 Key-Value 数据库</li>
</ul>
</li>
<li>Redis 有什么优点？<ul>
<li>速度快:数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</li>
<li>支持丰富数据类型:String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</li>
<li>丰富的特性: 订阅发布 Pub / Sub 功能,Key 过期策略,事务,支持多个 DB,计数</li>
<li>持久化存储: Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</li>
<li>高可用:内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移;内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</li>
</ul>
</li>
<li>Redis 有什么缺点？<ul>
<li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。(可使用 Redis Cluster、Codis 等方案，对 Redis 进行分区，从单机 Redis 变成集群 Redis 。)</li>
<li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</li>
</ul>
</li>
<li>请说说 Redis 的线程模型？<ul>
<li>Redis 是非阻塞 IO ，多路复用。</li>
</ul>
</li>
<li>为什么 Redis 单线程模型也能效率这么高？<ul>
<li> C 语言实现。</li>
<li> 纯内存操作。</li>
<li> 基于非阻塞的 IO 多路复用机制。</li>
<li> 单线程，避免了多线程的频繁上下文切换问题。</li>
</ul>
</li>
<li>Redis 是单线程的，如何提高多核 CPU 的利用率？<ul>
<li>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU ，你可以考虑一下分区。</li>
</ul>
</li>
<li>Redis 有几种持久化方式？<ul>
<li>【全量】RDB 持久化<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</li>
<li>RDB 优点：<ul>
<li>灵活设置备份频率和周期。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复</li>
<li>非常适合冷备份，对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，</li>
<li>性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。</li>
<li>恢复更快。相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况</li>
</ul>
</li>
<li>RDB 缺点：<ul>
<li>如果想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li>
<li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。</li>
</ul>
</li>
</ul>
</li>
<li>【增量】AOF持久化<ul>
<li>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
<li>AOF 优点<ul>
<li>该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了 3 种同步策略，即每秒同步、每修改(执行一个命令)同步和不同步。</li>
<li>由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。（redis-check-aof）</li>
<li>如果 AOF 日志过大，Redis 可以自动启用 rewrite 机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li>
</ul>
</li>
<li>AOF 缺点<ul>
<li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。</li>
<li>以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>
</ul>
</li>
</ul>
</li>
<li>如何选择：<ul>
<li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据。</li>
<li>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</li>
<li>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li>
</ul>
</li>
<li>AOF rewrite 机制，和 RDB 一样，也需要 fork 出一次子进程，如果 Redis 内存比较大，可能会因为 fork 阻塞下主进程。</li>
</ul>
</li>
<li>Redis 有哪几种数据“淘汰”策略？<ul>
<li>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。Redis 提供了 6 种数据淘汰策略：<ul>
<li>volatile-lru</li>
<li>volatile-ttl</li>
<li>volatile-random</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>【默认策略】no-enviction</li>
</ul>
</li>
</ul>
</li>
<li>Redis LRU 算法<ul>
<li> Redis 的 LRU 算法，并不是一个严格的 LRU 实现。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</li>
<li> Redis 没有使用真正实现严格的 LRU 算是的原因是，因为消耗更多的内存。然而对于使用 Redis 的应用来说，使用近似的 LRU 算法，事实上是等价的。</li>
</ul>
</li>
<li>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？<ul>
<li>选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</li>
</ul>
</li>
<li>Redis 回收进程如何工作的？<ul>
<li>一个客户端运行了新的写命令，添加了新的数据。</li>
<li>Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>Redis 执行新命令。</li>
<li>不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下（跌宕起伏）。</li>
</ul>
</li>
<li>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<ul>
<li>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</li>
<li>调大 hz 参数，每次过期的 key 更多，从而最终达到避免一次过期过多。<ul>
<li> hz 参数代表了一秒钟内，后台任务期望被调用的次数,hz 调大将会提高 Redis 主动淘汰的频率</li>
</ul>
</li>
<li>一般需要在时间上加一个随机值，使得过期时间分散一些。</li>
</ul>
</li>
<li>Redis 有哪些数据结构？<ul>
<li>初级<ul>
<li>字符串 String</li>
<li>字典Hash</li>
<li>列表List</li>
<li>集合Set</li>
<li>有序集合 SortedSet</li>
</ul>
</li>
<li>中级<ul>
<li>HyperLogLog</li>
<li>Geo</li>
<li>Bitmap</li>
</ul>
</li>
<li>高级<ul>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
<li>JSON</li>
</ul>
</li>
</ul>
</li>
<li>聊聊 Redis 使用场景/为什么使用redis<ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
</li>
<li>Redis 支持的 Java 客户端都有哪些？<ol>
<li>Redisson：封装好</li>
<li>Jedis：命令全</li>
<li>Lettuce：是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</li>
</ol>
</li>
<li>如何使用 Redis 实现分布式锁？<ul>
<li>正确的获得锁：set 指令附带 nx 参数，保证有且只有一个进程获得到。</li>
<li>正确的释放锁：使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放。</li>
<li>超时的自动释放锁：set 指令附带 expire 参数，通过过期机制来实现超时释放。</li>
<li>未获得到锁的等待机制：sleep 或者基于 Redis 的订阅 Pub/Sub 机制。一些业务场景，可能需要支持获得不到锁，直接返回 false ，不等待。</li>
<li>锁超时的处理：告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证有且仅有一个线程，正在持有锁。</li>
<li>set 指令：<code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></li>
<li>Redlock: Redisson 实现，所有master超过半数</li>
</ul>
</li>
<li>Redis 分布式锁 对比 Zookeeper 分布式锁<ul>
<li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li>
<li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li>
</ul>
</li>
<li>如何使用 Redis 实现消息队列？<ul>
<li>使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</li>
<li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li>
<li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li>
<li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li>
<li>果对方追问 redis 如何实现延时队列？使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li>
</ul>
</li>
<li>Redis 如何做大量数据插入？<ul>
<li>Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</li>
</ul>
</li>
<li>什么是 Redis 事务？<ul>
<li>MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石<ul>
<li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</li>
<li>和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</li>
<li>我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 “BEGIN TRANSACTION” 语句。在该语句之后执行的命令，都将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。(开启事务后，所有语句，发送给 Redis Server ，都会暂存在 Server 中。)</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</li>
</ul>
</li>
</ul>
</li>
<li>如何实现 Redis CAS 操作？<ul>
<li>在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set) 功能。</li>
<li>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 nil 应答以通知调用者事务执行失败</li>
</ul>
</li>
<li>Redis 集群都有哪些方案？<ul>
<li>Redis Sentinel<ul>
<li>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</li>
</ul>
</li>
<li>Redis Cluster<ul>
<li>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</li>
</ul>
</li>
<li>多大体量需要使用 Redis Cluster 呢<ol>
<li>一次 RDB 时间随着内存越大，会变大越来越久。同时，一次 fork 的时间也会变久。还有，重启通过 RDB 文件，或者 AOF 日志，恢复时间都会变长。</li>
<li>体量大之后，读写的 QPS 势必比体量小的时候打的多，那么使用 Redis Cluster 相比 Redis Sentinel ，可以分散读写压力到不同的集群中。</li>
</ol>
</li>
</ul>
</li>
<li>什么是 Redis 主从同步？<ul>
<li>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</li>
<li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li>
<li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li>
<li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
</li>
<li>Redis Cluster 的主从复制模型是怎样的？<ul>
<li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有 N-1 个复制节点。</li>
<li>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：<ul>
<li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li>
</ul>
</li>
</ul>
</li>
<li>Redis Cluster 方案什么情况下会导致整个集群不可用？<ul>
<li>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。当然，这种情况也可以配置 cluster-require-full-coverage=no ，整个集群无需所有槽位覆盖。</li>
</ul>
</li>
<li>Redis Cluster 会有写操作丢失吗？为什么？<ul>
<li>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li>
<li>无论对于 Redis Sentinel 还是 Redis Cluster 方案，都是通过主从复制，所以在数据的复制方面，都存在相同的情况。</li>
</ul>
</li>
<li>Redis 集群如何选择数据库？<ul>
<li>Redis 集群目前无法做数据库选择，默认在 0 数据库。</li>
</ul>
</li>
<li>请说说生产环境中的 Redis 是怎么部署的？<ul>
<li>Redis Cluster ，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li>
<li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10G 内存，一般线上生产环境，Redis 的内存尽量不要超过 10G，超过 10G 可能会有问题。那么，5 台机器对外提供读写，一共有 50G 内存。</li>
<li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li>
<li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1G 。常驻内存的是 200 万条商品数据，占用内存是 20G ，仅仅不到总内存的 50% 。目前高峰期每秒就是 3500 左右的请求量。</li>
<li>公司体量大了之后，建议是一个业务线独占一个或多个 Redis Cluster 集群，实现好业务线与业务线之间的隔离。</li>
</ul>
</li>
<li>什么是 Redis 分区？<ul>
<li>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</li>
<li>分区的优势:通过利用多台计算机内存的和值，允许我们构造更大的数据库。通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
<li>分区的不足:不支持涉及多个key的操作通</li>
<li>分区类型:范围分区 &amp;&amp; 哈希分区</li>
</ul>
</li>
<li>Redis 有哪些重要的健康指标？<ul>
<li>存活情况</li>
<li>连接数</li>
<li>阻塞客户端数量</li>
<li>使用内存峰值</li>
<li>内存碎片率</li>
<li>缓存命中率</li>
<li>OPS</li>
<li>持久化</li>
<li>失效KEY</li>
<li>慢日志</li>
</ul>
</li>
<li>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？<ul>
<li>Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</li>
<li>任何 list、set、和 sorted set 都可以放 2^32 </li>
</ul>
</li>
<li>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<ul>
<li>keys 指令可以扫出指定模式的 key 列表。</li>
<li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</li>
<li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li>
</ul>
</li>
<li>Redis 常见的性能问题都有哪些？如何解决？<ul>
<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</li>
<li></li>
</ul>
</li>
<li>Redis雪崩<ul>
<li><ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849210200503.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
<li>同一时间大量缓存失效，请求直接落到数据库，造成数据库崩溃</li>
<li>解决方式：<ul>
<li>失效期设置永不过期</li>
<li>失效期添加随机数</li>
<li>设置多层缓存，redis失效的情况下，使用内部缓存</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>缓存穿透，缓存击穿,雪崩的区别<ul>
<li>缓存穿透是指缓存和数据库中都没有的数据，比如id=-1导致数据库压力过大<ul>
<li>参数校验保证数据合法性</li>
<li>缓存假结果，添加失效期</li>
<li><ul>
<li><img src="https://anzhen-tech-imges.oss-cn-beijing.aliyuncs.com/2021/11/07/15849213541298.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_YW56aGVuLnRlY2g,size_40,x_10,y_10"></li>
</ul>
</li>
</ul>
</li>
<li>缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库<ul>
<li>设置热点数据永远不过期</li>
</ul>
</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2021
        <i class="ri-heart-fill heart_icon"></i> Anzhen
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="anzhen.tech"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/HDFS">HDFS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Yarn">Yarn</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/MR">MR</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Hive">Hive</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86">数据采集</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/HBase">HBase</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Kafka">Kafka</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Spark">Spark</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Flink">Flink</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/MySQL">MySQL</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Java">Java</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/interview">面试宝典</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/11/07/about-me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=318916815&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>